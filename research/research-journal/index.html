<!DOCTYPE html>
<html lang="en-us">
<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>Research Journal - Probabilistic Effects.  λθ</title>
<meta name="generator" content="Hugo 0.78.2" />
<link href="https://min-nguyen.github.io//index.xml" rel="alternate" type="application/rss+xml">
<link rel="canonical" href="https://min-nguyen.github.io/research/research-journal/">
<link rel="stylesheet" href="https://min-nguyen.github.io/css/theme.min.css">
<script src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script>
<link rel="stylesheet" href="https://min-nguyen.github.io/css/chroma.min.css">
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script>
<script src="https://min-nguyen.github.io/js/bundle.js"></script><style>
:root {}
</style>
<meta property="og:title" content="Research Journal" />
<meta property="og:description" content="• Scrum Meeting 1 (Meng &#43; Sam &#43; Minh)
  Can the inference monad transformer stack of a program be inferred/fixed at compile time?
  Identifying smaller goals and intermediate research ideas and what is valuable to do:
 What&rsquo;s the line between papers and a very good blog post? (new things are papers) How can research/observations across monad-bayes be generalised? It is possible to do an empirical evaluation and target software dev audiences Programming languages field lacks proper evaluations; it is possible to question existing &ldquo;folklore&rdquo; with new observed results&quot; It is important to know what the benchmarking tool can and can&rsquo;t do - when experimenting we must always ask what can the tool do for me." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://min-nguyen.github.io/research/research-journal/" />
<meta property="article:published_time" content="2020-11-13T14:05:57+00:00" />
<meta property="article:modified_time" content="2020-11-13T14:05:57+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Research Journal"/>
<meta name="twitter:description" content="• Scrum Meeting 1 (Meng &#43; Sam &#43; Minh)
  Can the inference monad transformer stack of a program be inferred/fixed at compile time?
  Identifying smaller goals and intermediate research ideas and what is valuable to do:
 What&rsquo;s the line between papers and a very good blog post? (new things are papers) How can research/observations across monad-bayes be generalised? It is possible to do an empirical evaluation and target software dev audiences Programming languages field lacks proper evaluations; it is possible to question existing &ldquo;folklore&rdquo; with new observed results&quot; It is important to know what the benchmarking tool can and can&rsquo;t do - when experimenting we must always ask what can the tool do for me."/>
<meta itemprop="name" content="Research Journal">
<meta itemprop="description" content="• Scrum Meeting 1 (Meng &#43; Sam &#43; Minh)
  Can the inference monad transformer stack of a program be inferred/fixed at compile time?
  Identifying smaller goals and intermediate research ideas and what is valuable to do:
 What&rsquo;s the line between papers and a very good blog post? (new things are papers) How can research/observations across monad-bayes be generalised? It is possible to do an empirical evaluation and target software dev audiences Programming languages field lacks proper evaluations; it is possible to question existing &ldquo;folklore&rdquo; with new observed results&quot; It is important to know what the benchmarking tool can and can&rsquo;t do - when experimenting we must always ask what can the tool do for me.">
<meta itemprop="datePublished" content="2020-11-13T14:05:57+00:00" />
<meta itemprop="dateModified" content="2020-11-13T14:05:57+00:00" />
<meta itemprop="wordCount" content="1793">



<meta itemprop="keywords" content="" />
</head>
<body><div class="container"><header>
<h1>Probabilistic Effects.  λθ</h1>
</header>

<div class="content-container">
<main><h1>Research Journal</h1>
<p><strong>• Scrum Meeting 1 (Meng + Sam + Minh)</strong></p>
<ul>
<li>
<p>Can the inference monad transformer stack of a program be inferred/fixed at compile time?</p>
</li>
<li>
<p>Identifying smaller goals and intermediate research ideas and what is valuable to do:</p>
<ul>
<li>What&rsquo;s the line between papers and a very good blog post? (new things are papers)</li>
<li>How can research/observations across monad-bayes be generalised?</li>
<li>It is possible to do an empirical evaluation and target software dev audiences</li>
<li>Programming languages field lacks proper evaluations; it is possible to question existing &ldquo;folklore&rdquo; with new observed results&quot;</li>
<li>It is important to know what the benchmarking tool can and can&rsquo;t do - when experimenting we must always ask what can the tool do for me. Goal is guided by what you can measure.</li>
</ul>
</li>
</ul>
<p><strong>• Scrum Meeting 2 (Meng + Sam + Minh)</strong></p>
<ul>
<li>Meeting with Alessio</li>
<li>They now have a visualiser for the profiling info :0 cool</li>
<li>Also reading up on three different effect system optimisation approaches inc
<ul>
<li>Alexis King delimited things and the Cont monad. Jamie is being nice and helpful</li>
<li>something else Csongor used</li>
<li>staging</li>
<li>tagless final style
<ul>
<li>Sam has read this paper. Here are her notes:
Sam F: Typed tagless final style if a good approach from embedding a DSL Pros: Types are preserved Efficient Doesn&rsquo;t get stuck Can express pattern matching and non-compositional things Extensible The heart of this style is adding a type param polymorphism and parameterisation.
Nick W: “it is a precursor to algebraic effects” Tagless final style and algebraic effects are just implementations within a broader field, it would be better to understand the general specification of how to embed properly Following Nick’s advice I will now read a few papers that give me a broader insight into the field of algebraic effects, to get the more general view, instead of focusing on a specific implementation
Suggested papers: &ldquo;Handlers of Algebraic Effects, Programming and Reasoning with Algebraic Effects and Effect Handlers, From Theory to Practice of Algebraic Effects and Handlers (Sam started reading the first, but found it a bit hard because I lacked knowledge in that area).</li>
</ul>
</li>
</ul>
</li>
<li>plan = implement using three different systems then see what happens
Meng: sounds like a lot of work
Minh: yes this is just our path, hopefully we will find something interesting on the way
Meng: just use a minimal calculus fro experiments, then have Monad Bayes as the big example</li>
<li>Monad Bayes is a shallow embedding, so naturally it is less efficient than a deep embedding
Research is like digging for gold. Sometimes you find big, sometimes you find small.
Engineers did for coal, scientists dig for gold.
Remember PhD research will accelerate. It is not a linear path. Matt didnt know what he was doing till end of second year. Everyone has a period of uncertainty. This is fine. Everything will be okay.
In academia you will constantly be haunted by the guilt of research vs teaching.
Protect your research time!!!</li>
<li>Meng: Minh you have good plans how will you execute</li>
<li>Minh: A and I have weekly meetings so that should keep us churning. Currently reading and writing up notes, while also doing some coding and discussing each week. progressing well</li>
<li>Meng: reading with a purpose is good! Reading with purpose is the best!</li>
</ul>
<p><strong>• Slack Conversation (Minh + Jamie)</strong></p>
<ul>
<li>
<p>Minh: Do you know a good paper/resource on how staging can be used to optimise effect systems in general?</p>
</li>
<li>
<p>Jamie Willis: nope, it hasn&rsquo;t been done in general yet - there are people working on this. Staged SOP and the Parsley paper both provide meaningful nuggets about how to use staging for optimisation</p>
</li>
</ul>
<p><strong>• Slack Conversation (Minh + Nick)</strong></p>
<ul>
<li>
<p>Minh: Do you know a good paper/resource on how staging can be used to optimize effect systems?</p>
</li>
<li>
<p>Nick: Hah, I am working on this at the moment. I think it&rsquo;s a natural combination of the work on staging I&rsquo;ve been doing with Matt and the Fusion for Free work. By the way, I think I was waiting for you and Alessio to get in touch about putting something together? Did I drop a ball?</p>
</li>
<li>
<p>Minh: No balls have been dropped, we&rsquo;re progressing, but nothing exists which is worth your time yet, just still a lot of reading</p>
</li>
<li>
<p>Nick: You&rsquo;re asking about staging and effects: is it because you want to go in that direction, or just curiosity?</p>
</li>
<li>
<p>Minh: Because we most likely want to explore that direction. I think the current idea is take the monad-bayes (which is a slow probabilistic programming library in Haskell) and implement a similar idea using different effect systems to understand what happens and why to the performance - hopefully something interesting will come out of it</p>
</li>
<li>
<p>Nick: That all sounds promising. It&rsquo;d be good to meet and chat about it all at some point, but I appreciate that you and Alessio might still be reading. This&rsquo;ll probably be related: <a href="https://dl.acm.org/doi/pdf/10.1145/3408975">https://dl.acm.org/doi/pdf/10.1145/3408975</a></p>
</li>
<li>
<p>Minh: Definitely, i&rsquo;ll see where we&rsquo;re at and try to propose a good conversation when we&rsquo;re ready + thanks!</p>
</li>
<li>
<p>Nick: You&rsquo;re welcome!</p>
</li>
</ul>
<p><strong>• Discussion following previous chat with Nick (Minh + Alessio)</strong></p>
<ul>
<li>
<p>Alessio: We were meant to be doing something with him?</p>
</li>
<li>
<p>Minh: I asked him like a few months ago if he&rsquo;d like to talk with us about what we&rsquo;re doing and offer some insight, and he seemed quite interested</p>
</li>
<li>
<p>Alessio: Fair enough. That link looks more like actually writing an effect system, not using an existing one. I&rsquo;m a bit reticent to get involved in actually creating effect systems</p>
</li>
<li>
<p>Minh: Yeah that&rsquo;s fair enough</p>
</li>
<li>
<p>Alessio: Might be a good place to go after potentially - as in, a natural path after using these effect systems would probably be developing one. It&rsquo;s not something i&rsquo;m particularly interested in at the moment but it might be for you</p>
</li>
<li>
<p>Minh: Mmm yeah, suppose we&rsquo;ll see how things go</p>
</li>
<li>
<p>Alessio: Fusion for free w/ staging seems like a p obviously successful idea
I have the vague intuition for how that might work. But I&rsquo;m not smart enough to see the path forward there. I mean what nick said he was working on, (nothing to do with us).</p>
</li>
<li>
<p>Minh: Do you feel fusion for free is relevant</p>
</li>
<li>
<p>Alessio: My intuition says yes but my head says that Alexis kings library is our best bet. Also, I see that Meng suggested a restricted calculus - I need to mull on that but I can see it being possible</p>
</li>
<li>
<p>Minh: The thing is with <code>Eff</code>, is that just a case of waiting for her proposal to come through?</p>
</li>
<li>
<p>Alessio: Her library exists as a fork of GHC. We can just use that fork with the patch and the library. No need to wait</p>
</li>
<li>
<p>Minh: Oh that&rsquo;s been done? Nice.</p>
</li>
<li>
<p>Alessio: Yeah, I think Eff is like early stage but it looks stable enough for us to use. I think we should start there in my opinion. We have the library so it shouldn&rsquo;t be a huge step re-implementing. And to be honest I think if it works it&rsquo;s obviously the best suggestion. Why rewrite everything in a complex way when you can just move to the same system but better? If you want something to do currently which is computational related, i think working out how to get the Alexis King&rsquo;s patch and library working is a good idea.</p>
</li>
<li>
<p>Minh: Sounds good</p>
</li>
<li>
<p>Alessio: This looks like the patch branch: <a href="https://github.com/lexi-lambda/ghc-proposals/tree/delimited-continuation-primops">https://github.com/lexi-lambda/ghc-proposals/tree/delimited-continuation-primops</a></p>
</li>
<li>
<p>Minh: I&rsquo;m also looking at it in a way of how do i turn this into research, rather than a use case.</p>
</li>
<li>
<p>Alessio: Not too sure there to be honest - the research aspect would be comparing the different methods in my opinion. If you&rsquo;re looking for new <em>things</em>, then maybe the stuff Nick is working on? I think <em>just</em> staging it or <em>just</em> using codensity/fusion stuff would count as novel research, given that Jamie has a paper on staging parsley</p>
</li>
<li>
<p>Minh: That&rsquo;s true</p>
</li>
<li>
<p>Alessio: I also think case studies/methodology papers like &ldquo;how to optimise something built on an effect system&rdquo; are research but sometimes academia can be a bit snooty.
In my opinion it&rsquo;s the most important research but academia gonna academia.</p>
</li>
<li>
<p>Minh: Yeah that&rsquo;s my annoyance too</p>
</li>
<li>
<p>Alessio: Its up to you I guess. If you think it&rsquo;s too risky maybe just staging or doing fusion would be best as that would be novel. But if you&rsquo;re more inclined to do the case study stuff I think going to <code>eff</code> would be the best first move. I&rsquo;m open to either but I think I&rsquo;ll end up doing eff either way as I think it&rsquo;s the best bet to actually make it faster</p>
</li>
<li>
<p>Minh: What&rsquo;s too risky?</p>
</li>
<li>
<p>Alessio: I mean like you&rsquo;d rather not do the case study methodology think out of a fear of some kind of lack of appreciation</p>
</li>
<li>
<p>Minh: Oh, by using Eff? Why do you see that as a case study as opposed to taking a staging or fusion approach on monad-bayes?</p>
</li>
<li>
<p>Alessio: I think staging is just more involved and would require more novel insight / the path is less charted. I think Eff would be easier to reimplement with essentially</p>
</li>
<li>
<p>Minh: Ah okay i get you. I agree that starting with Eff is the best idea - we&rsquo;ll be able to reach a milestone faster and feel a bit better about taking other approaches (or i will at least).</p>
</li>
<li>
<p>Alessio: I think we can get that done by the end of the year, or early Jan. Who knows, we might run into problems.</p>
</li>
</ul>
<p><strong>Meeting (Minh + Alessio)</strong></p>
<p>Analysing profile report on PMMH inference for a HMM:</p>
<p><img src="https://i.ibb.co/6mv24Cp/pmmh-prof.png" alt=""></p>
<p>The key points of interest are:</p>
<ul>
<li>
<p>The <code>(&gt;&gt;=)</code> operation which occurs in <code>Population.hs</code>, accounting for 35% of the total runtime. The source line responsible for this is found in the typeclass derivations of the <code>Population</code> newtype, namely the deriving of the <code>Monad</code> class.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#75715e">-- | A collection of weighted samples, or particles.</span>
<span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">Population</span> m a <span style="color:#f92672">=</span> <span style="color:#66d9ef">Population</span> (<span style="color:#66d9ef">Weighted</span> (<span style="color:#66d9ef">ListT</span> m) a)
  <span style="color:#66d9ef">deriving</span> (<span style="color:#66d9ef">Functor</span>, <span style="color:#66d9ef">Applicative</span>, <span style="color:#66d9ef">Monad</span>, <span style="color:#66d9ef">MonadIO</span>, <span style="color:#66d9ef">MonadSample</span>, <span style="color:#66d9ef">MonadCond</span>, <span style="color:#66d9ef">MonadInfer</span>)
</code></pre></div></li>
<li>
<p>The <code>liftA2</code> operation and the <code>pure</code> operation which both occur in <code>Weighted.hs</code>, accounting for 11.9% and 7.9% of the total runtime respectively. The source line responsible for this is found in the typeclass derivations of the <code>Weighted</code> newtype, namely the deriving of the <code>Applicative</code> class.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#75715e">-- | Execute the program using the prior distribution, while accumulating likelihood.</span>
<span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">Weighted</span> m a <span style="color:#f92672">=</span> <span style="color:#66d9ef">Weighted</span> (<span style="color:#66d9ef">StateT</span> (<span style="color:#66d9ef">Log</span> <span style="color:#66d9ef">Double</span>) m a)
  <span style="color:#75715e">-- StateT is more efficient than WriterT</span>
  <span style="color:#66d9ef">deriving</span> (<span style="color:#66d9ef">Functor</span>, <span style="color:#66d9ef">Applicative</span>, <span style="color:#66d9ef">Monad</span>, <span style="color:#66d9ef">MonadIO</span>, <span style="color:#66d9ef">MonadTrans</span>, <span style="color:#66d9ef">MonadSample</span>)
</code></pre></div></li>
</ul>
<p>These overheads are associated with the inference representations/transformer stack which <code>monad-bayes</code> uses, as opposed to time spent on numerical computation such as with the <code>bernoulli</code> function.</p>
<p>This prompts the questions:</p>
<ul>
<li>What definitions of <code>(&gt;&gt;=)</code>, <code>liftA2</code>, and <code>pure</code> are generated as a result of using <code>deriving</code>, and why are these inefficient for our case?</li>
</ul>
<div class="edit-meta">
Last updated on 13 Nov 2020


<br>
Published on 13 Nov 2020
<br></div><nav class="pagination"><a class="nav nav-prev" href="https://min-nguyen.github.io/research/" title="Research"><i class="fas fa-arrow-left" aria-hidden="true"></i> Prev - Research</a>
<a class="nav nav-next" href="https://min-nguyen.github.io/research/approaches-for-monad-bayes/" title="Potential Approaches to Improving Monad Bayes">Next - Potential Approaches to Improving Monad Bayes <i class="fas fa-arrow-right" aria-hidden="true"></i></a>
</nav><footer><p class="powered">Powered by <a href="https://gohugo.io">Hugo</a>. Theme by <a href="https://themes.gohugo.io/hugo-theme-techdoc/">TechDoc</a>. Designed by <a href="https://github.com/thingsym/hugo-theme-techdoc">Thingsym</a>.</p>
</footer>
</main>
<div class="sidebar">

<nav class="open-menu">
<ul>
<li class=""><a href="https://min-nguyen.github.io/">Home</a></li>

<li class="parent"><a href="https://min-nguyen.github.io/research/">Research</a>
  
<ul class="sub-menu">
<li class="active"><a href="https://min-nguyen.github.io/research/research-journal/">Research Journal</a></li>
<li class=""><a href="https://min-nguyen.github.io/research/approaches-for-monad-bayes/">Potential Approaches to Improving Monad Bayes</a></li>
<li class=""><a href="https://min-nguyen.github.io/research/effects-for-less/">Effects for Less - Alexis King&#39;s Talk Summary</a></li>
</ul>
  
</li>

<li class=""><a href="https://min-nguyen.github.io/monad-bayes/">Monad Bayes</a>
  
<ul class="sub-menu">
<li class=""><a href="https://min-nguyen.github.io/monad-bayes/inference-transformers/">Inference Transformers</a></li>
<li class=""><a href="https://min-nguyen.github.io/monad-bayes/pmmh-hmm/">Implementing HMM Simulation and Inference (using PMMH)</a></li>
<li class=""><a href="https://min-nguyen.github.io/monad-bayes/conditioning-scoring/">How Conditioning and Scoring Works</a></li>
</ul>
  
</li>

<li class=""><a href="https://min-nguyen.github.io/benchmarking/">Benchmarking</a>
  
<ul class="sub-menu">
<li class=""><a href="https://min-nguyen.github.io/benchmarking/benchmarking-profiling/">How to Benchmark and Profile</a></li>
<li class=""><a href="https://min-nguyen.github.io/benchmarking/monad-bayes-components/">Relevant Components of Monad Bayes for Profiling</a></li>
</ul>
  
</li>

<li class=""><a href="https://min-nguyen.github.io/background/">Background</a>
  
<ul class="sub-menu">
<li class=""><a href="https://min-nguyen.github.io/background/staging/">Staging</a></li>
<li class=""><a href="https://min-nguyen.github.io/background/smc-pmmh/">SMC and PMMH</a></li>
<li class=""><a href="https://min-nguyen.github.io/background/performance-w-monads/">Performance With Monads</a></li>
<li class=""><a href="https://min-nguyen.github.io/background/mtl/">MTL</a></li>
<li class=""><a href="https://min-nguyen.github.io/background/mcmc-mh/">MCMC and MH</a></li>
<li class=""><a href="https://min-nguyen.github.io/background/markov-chain/">Markov Chains</a></li>
<li class=""><a href="https://min-nguyen.github.io/background/hidden-markov-model/">Hidden Markov Model</a></li>
<li class=""><a href="https://min-nguyen.github.io/background/delimited-continuations/">Delimited Continuations</a></li>
<li class=""><a href="https://min-nguyen.github.io/background/continuations/">Continuations</a></li>
</ul>
  
</li>
</ul>
</nav>



<div class="sidebar-footer"></div>
</div>

</div><a href="#" id="backtothetop-fixed" class="backtothetop"
 data-backtothetop-duration="600"
 data-backtothetop-easing="easeOutQuart"
 data-backtothetop-fixed-fadeIn="1000"
 data-backtothetop-fixed-fadeOut="1000"
 data-backtothetop-fixed-bottom="10"
 data-backtothetop-fixed-right="20">
<span class="fa-layers fa-fw">
<i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i>
</span></a>
</div>
</body>
</html>

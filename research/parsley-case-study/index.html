<!DOCTYPE html>
<html lang="en-us">
<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>Case Study: Optimising Parsley - Probabilistic Effects.  λθ</title>
<meta name="generator" content="Hugo 0.80.0" />
<link href="https://probabilistic-effects.github.io//index.xml" rel="alternate" type="application/rss+xml">
<link rel="canonical" href="https://probabilistic-effects.github.io/research/parsley-case-study/">
<link rel="stylesheet" href="https://probabilistic-effects.github.io/css/theme.min.css">
<script src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script>
<link rel="stylesheet" href="https://probabilistic-effects.github.io/css/chroma.min.css">
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script>
<script src="https://probabilistic-effects.github.io/js/bundle.js"></script><style>
:root {}
</style>
<meta property="og:title" content="Case Study: Optimising Parsley" />
<meta property="og:description" content="The best way to understand why a profiling report outputs certain performance metrics (for Haskell) is to dive into the actual core itself, which is what the surface-level Haskell code compiles down into.
Usually, if one is confused about something in the core, it is best to compare it with the original program.
regTest :: Parser Int regTest = newRegister_ (code 7) (\r -&gt; modify_ r makeQ (succ @Int) [||succ @Int||]) *&gt; (let g = get r in g *&gt; g)) This makes a new register, which in this context would be an STRef, containing 7; it then modifies it with &#43;1, and afterwards it gets the value out twice, and returns it the second time." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://probabilistic-effects.github.io/research/parsley-case-study/" />
<meta property="article:published_time" content="2020-11-13T13:49:05+00:00" />
<meta property="article:modified_time" content="2020-11-13T13:49:05+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Case Study: Optimising Parsley"/>
<meta name="twitter:description" content="The best way to understand why a profiling report outputs certain performance metrics (for Haskell) is to dive into the actual core itself, which is what the surface-level Haskell code compiles down into.
Usually, if one is confused about something in the core, it is best to compare it with the original program.
regTest :: Parser Int regTest = newRegister_ (code 7) (\r -&gt; modify_ r makeQ (succ @Int) [||succ @Int||]) *&gt; (let g = get r in g *&gt; g)) This makes a new register, which in this context would be an STRef, containing 7; it then modifies it with &#43;1, and afterwards it gets the value out twice, and returns it the second time."/>
<meta itemprop="name" content="Case Study: Optimising Parsley">
<meta itemprop="description" content="The best way to understand why a profiling report outputs certain performance metrics (for Haskell) is to dive into the actual core itself, which is what the surface-level Haskell code compiles down into.
Usually, if one is confused about something in the core, it is best to compare it with the original program.
regTest :: Parser Int regTest = newRegister_ (code 7) (\r -&gt; modify_ r makeQ (succ @Int) [||succ @Int||]) *&gt; (let g = get r in g *&gt; g)) This makes a new register, which in this context would be an STRef, containing 7; it then modifies it with &#43;1, and afterwards it gets the value out twice, and returns it the second time.">
<meta itemprop="datePublished" content="2020-11-13T13:49:05+00:00" />
<meta itemprop="dateModified" content="2020-11-13T13:49:05+00:00" />
<meta itemprop="wordCount" content="12484">



<meta itemprop="keywords" content="" />
</head>
<body><div class="container"><header>
<h1>Probabilistic Effects.  λθ</h1>
</header>

<div class="content-container">
<main><h1>Case Study: Optimising Parsley</h1>
<p>The best way to understand why a profiling report outputs certain performance metrics (for Haskell) is to dive into the actual core itself, which is what the surface-level Haskell code compiles down into.</p>
<p>Usually, if one is confused about something in the core, it is best to compare it with the original program.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">regTest</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Parser</span> <span style="color:#66d9ef">Int</span>
<span style="color:#a6e22e">regTest</span> <span style="color:#f92672">=</span> newRegister_ (code <span style="color:#ae81ff">7</span>) (<span style="color:#a6e22e">\</span>r <span style="color:#f92672">-&gt;</span> modify_ r makeQ (succ <span style="color:#f92672">@</span><span style="color:#66d9ef">Int</span>) [<span style="color:#f92672">||</span>succ <span style="color:#f92672">@</span><span style="color:#66d9ef">Int</span><span style="color:#f92672">||</span>]) <span style="color:#f92672">*&gt;</span> (<span style="color:#66d9ef">let</span> g <span style="color:#f92672">=</span> get r <span style="color:#66d9ef">in</span> g <span style="color:#f92672">*&gt;</span> g))
</code></pre></div><p>This makes a new register, which in this context would be an <code>STRef</code>, containing 7; it then modifies it with <code>+1</code>, and afterwards it gets the value out twice, and returns it the second time.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">(<span style="color:#ae81ff">32</span>) lvl <span style="color:#f92672">=</span>
 λs1 <span style="color:#f92672">-&gt;</span>
   <span style="color:#75715e">-- Using &#39;newMutVar&#39;, it makes the new register containing a value &#39;lvl&#39; we expect to be 7.</span>
   <span style="color:#66d9ef">let</span><span style="color:#f92672">!</span> (<span style="color:#f92672">#</span>, <span style="color:#f92672">#</span>) ipv ipv1 <span style="color:#f92672">=</span> newMutVar<span style="color:#f92672">#</span> lvl s1 <span style="color:#66d9ef">in</span>
   <span style="color:#75715e">-- Using &#39;readMutVar&#39;, it then reads then 7 to get an int out in ipv1</span>
   <span style="color:#66d9ef">let</span><span style="color:#f92672">!</span> (<span style="color:#f92672">#</span>, <span style="color:#f92672">#</span>) ipv ipv1 <span style="color:#f92672">=</span> readMutVar<span style="color:#f92672">#</span> ipv1 ipv <span style="color:#66d9ef">in</span>
   <span style="color:#75715e">-- It performs the succ function on value 7 (ipv1) and puts it back in the hole using &#39;writeMutVar&#39;</span>
   <span style="color:#66d9ef">let</span><span style="color:#f92672">!</span> s2<span style="color:#f92672">#</span> <span style="color:#f92672">=</span> writeMutVar<span style="color:#f92672">#</span> ipv1 (<span style="color:#f92672">$</span>fEnumInt_<span style="color:#f92672">$</span>csucc ipv1) ipv <span style="color:#66d9ef">in</span>
   <span style="color:#75715e">-- We read from the register twice, using &#39;readMutVar&#39;, but we only care about the second value...</span>
   <span style="color:#66d9ef">let</span><span style="color:#f92672">!</span> (<span style="color:#f92672">#</span>, <span style="color:#f92672">#</span>) ipv <span style="color:#66d9ef">_</span> <span style="color:#f92672">=</span> readMutVar<span style="color:#f92672">#</span> ipv1 s2<span style="color:#f92672">#</span> <span style="color:#66d9ef">in</span>
   <span style="color:#66d9ef">let</span><span style="color:#f92672">!</span> (<span style="color:#f92672">#</span>, <span style="color:#f92672">#</span>) ipv ipv1 <span style="color:#f92672">=</span> readMutVar<span style="color:#f92672">#</span> ipv1 ipv <span style="color:#66d9ef">in</span>
   <span style="color:#75715e">-- ... which is returned the second time after reading.</span>
   (<span style="color:#f92672">#</span>, <span style="color:#f92672">#</span>) ipv (<span style="color:#66d9ef">Just</span> ipv1)
</code></pre></div><p>Is there a way of seeing if what your code compiles down into is nonoptimal?
Usually we will see something we&rsquo;re unhappy with. In the above case, there is no chance that the core version of the program could be better. If we start seeing function applications or random case statements, we might be suspicious.</p>
<p>Consider the following code, which is supposed to take a sequence of alternating a&rsquo;s and b&rsquo;s and roll them all up:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">manyTest</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Parser</span> [<span style="color:#66d9ef">Char</span>]
<span style="color:#a6e22e">manyTest</span> <span style="color:#f92672">=</span> many (string <span style="color:#e6db74">&#34;ab&#34;</span> <span style="color:#f92672">$&gt;</span> (code <span style="color:#e6db74">&#39;c&#39;</span>))
</code></pre></div><p>In the core version of <code>manyTest</code>, one of the problems we can observe within it is that a particular function called <code>exit</code> is created twice:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">  λs1 <span style="color:#f92672">-&gt;</span>
    <span style="color:#f92672">...</span>
    <span style="color:#66d9ef">let</span>
      exit <span style="color:#f92672">=</span>
        λo<span style="color:#f92672">#</span> eta ipv <span style="color:#f92672">-&gt;</span>
          <span style="color:#66d9ef">case</span> <span style="color:#f92672">==#</span> o<span style="color:#f92672">#</span> ipv <span style="color:#66d9ef">of</span>
            <span style="color:#66d9ef">DEFAULT</span> <span style="color:#f92672">-&gt;</span>
              (<span style="color:#f92672">#</span>, <span style="color:#f92672">#</span>) eta <span style="color:#66d9ef">Nothing</span>
            <span style="color:#ae81ff">1</span> <span style="color:#f92672">-&gt;</span>
              <span style="color:#66d9ef">let</span><span style="color:#f92672">!</span> (<span style="color:#f92672">#</span>, <span style="color:#f92672">#</span>) ipv ipv1 <span style="color:#f92672">=</span> readMutVar<span style="color:#f92672">#</span> ipv1 eta <span style="color:#66d9ef">in</span>
              (<span style="color:#f92672">#</span>, <span style="color:#f92672">#</span>) ipv (<span style="color:#66d9ef">Just</span> (ipv1 <span style="color:#66d9ef">[]</span>))
      exit <span style="color:#f92672">=</span>
        λo<span style="color:#f92672">#</span> eta ipv <span style="color:#f92672">-&gt;</span>
          <span style="color:#66d9ef">case</span> <span style="color:#f92672">==#</span> o<span style="color:#f92672">#</span> ipv <span style="color:#66d9ef">of</span>
            <span style="color:#66d9ef">DEFAULT</span> <span style="color:#f92672">-&gt;</span>
              (<span style="color:#f92672">#</span>, <span style="color:#f92672">#</span>) eta <span style="color:#66d9ef">Nothing</span>
            <span style="color:#ae81ff">1</span> <span style="color:#f92672">-&gt;</span>
              <span style="color:#66d9ef">let</span><span style="color:#f92672">!</span> (<span style="color:#f92672">#</span>, <span style="color:#f92672">#</span>) ipv ipv1 <span style="color:#f92672">=</span> readMutVar<span style="color:#f92672">#</span> ipv1 eta <span style="color:#66d9ef">in</span>
              (<span style="color:#f92672">#</span>, <span style="color:#f92672">#</span>) ipv (<span style="color:#66d9ef">Just</span> (ipv1 <span style="color:#66d9ef">[]</span>))
</code></pre></div><p>The question becomes &ldquo;why has the compiler not worked out that these are the same functions, and duplicated it when it didn&rsquo;t need to?&rdquo;. In the body of the <code>let</code> statement of the core version, we can observe where <code>exit</code> is used - it tells us that the program checks if there is enough input, and if so, is that input the character &lsquo;b&rsquo;. So we expect the call of <code>exit</code> to be somewhere where we read characters.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">in</span>
   <span style="color:#66d9ef">let</span> <span style="color:#f92672">...</span>
   <span style="color:#66d9ef">in</span> <span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;#</span> ipv dt <span style="color:#66d9ef">of</span>
        <span style="color:#66d9ef">DEFAULT</span> <span style="color:#f92672">-&gt;</span>
          exit o<span style="color:#f92672">#</span> eta ipv
        <span style="color:#ae81ff">1</span> <span style="color:#f92672">-&gt;</span>
          <span style="color:#66d9ef">case</span> indexWideCharArray<span style="color:#f92672">#</span> input<span style="color:#f92672">#</span> ipv <span style="color:#66d9ef">of</span>
            <span style="color:#66d9ef">DEFAULT</span> <span style="color:#f92672">-&gt;</span>
              exit o<span style="color:#f92672">#</span> eta ipv
            <span style="color:#e6db74">&#39;b&#39;</span> <span style="color:#f92672">-&gt;</span>
              <span style="color:#f92672">...</span>
</code></pre></div><p>These  <code>exit</code> variables would have been defined in our original code somewhere. In this case, we can see the two different functions <code>sat</code> and <code>emitLengthCheck</code> both use the expression <code>$$bad</code> which represents the <code>exit</code> variable.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">sat</span> <span style="color:#f92672">...</span> <span style="color:#f92672">=</span>
  <span style="color:#f92672">...</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">...</span> <span style="color:#66d9ef">then</span> <span style="color:#f92672">...</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">$$</span>bad

<span style="color:#a6e22e">emitLengthCheck</span> <span style="color:#f92672">...</span> <span style="color:#f92672">=</span>
  <span style="color:#f92672">...</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">...</span> <span style="color:#66d9ef">then</span> <span style="color:#f92672">...</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">$$</span>bad
</code></pre></div><p>We fail in the case in which we don&rsquo;t have enough input, and we fail in the case where the character doesn&rsquo;t match. So we ask why these <code>exit</code> variables are two different values, when they could have been the same one - these calls to <code>$$bad</code> should really come from the same place. The question then becomes: &ldquo;how do we work out where they came from, and how do we trace them back to their common source?&rdquo;.</p>
<p>We can find that in some function <code>evalSat</code>, that we&rsquo;ve defined a function <code>maybeEmitCheck</code> that defines the <code>bad</code> variable in a <code>let</code> statement, and uses it twice in its body.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">evalSat</span> <span style="color:#f92672">..</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">do</span>
  <span style="color:#f92672">...</span>
  <span style="color:#66d9ef">where</span>
    maybeEmitCheck <span style="color:#f92672">...</span> <span style="color:#f92672">=</span>
      [<span style="color:#f92672">||</span> <span style="color:#66d9ef">let</span> bad <span style="color:#f92672">=</span> <span style="color:#f92672">$$</span>(raise y)
          <span style="color:#66d9ef">in</span> <span style="color:#f92672">$$</span>(emitLengthCheck n (sat (genDefunc p) mk [<span style="color:#f92672">||</span>bad<span style="color:#f92672">||</span>]) [<span style="color:#f92672">||</span>bad<span style="color:#f92672">||</span>] y)
       <span style="color:#f92672">||</span>]
</code></pre></div><p>The first usage of <code>bad</code> is the one that gets passed to <code>sat</code>, and the second usage is the one that gets passed to <code>emitLengthCheck</code>. We can correspond this to the previous core code: the first <code>exit</code> corresponds to the <code>bad</code> passed to <code>emitLengthCheck</code>, and the second <code>exit</code> corresponds to the <code>bad</code> passed to <code>sat</code>. In this case, we don&rsquo;t currently know why GHC has chosen to define <code>exit</code> twice.</p>
<p>We could also be curious as to whether certain operations can be factored out. For example, in the following code we could ask can these length checks <code>&lt;# o# dt</code> and <code>&lt;# ipv dt</code> be factored out - why is it doing these twice?</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">  λo<span style="color:#f92672">#</span> eta <span style="color:#f92672">-&gt;</span>
    <span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;#</span> o<span style="color:#f92672">#</span> dt <span style="color:#66d9ef">of</span>
      <span style="color:#66d9ef">DEFAULT</span> <span style="color:#f92672">-&gt;</span>
        exit eta
      <span style="color:#ae81ff">1</span> <span style="color:#f92672">-&gt;</span>
        <span style="color:#f92672">...</span>
        <span style="color:#66d9ef">let</span>
          ipv <span style="color:#f92672">=</span>
            <span style="color:#f92672">+#</span> o<span style="color:#f92672">#</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">in</span> <span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;#</span> ipv dt <span style="color:#66d9ef">of</span>
          <span style="color:#66d9ef">DEFAULT</span> <span style="color:#f92672">-&gt;</span>
            <span style="color:#f92672">...</span>
</code></pre></div><p>And we can actually fix this by changing the definition of <code>manyTest</code> to:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">manyTest</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Parser</span> [<span style="color:#66d9ef">Char</span>]
<span style="color:#a6e22e">manyTest</span> <span style="color:#f92672">=</span> many (try (string <span style="color:#e6db74">&#34;ab&#34;</span>) <span style="color:#f92672">$&gt;</span> (code <span style="color:#e6db74">&#39;c&#39;</span>))
</code></pre></div><p>Going back to the core, we can see now that the first length check has been replaced with the second length check i.e. it&rsquo;s been factored out. Because we always want to read an <code>a</code> character followed by a <code>b</code> character, this code will now always check if there are <em>atleast</em> two characters before trying to read any characters at all, rather than reading an <code>a</code> and then failing when there are no further characters.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">  λo<span style="color:#f92672">#</span> eta <span style="color:#f92672">-&gt;</span>
    <span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;#</span> (<span style="color:#f92672">+#</span> o<span style="color:#f92672">#</span> <span style="color:#ae81ff">1</span>) dt <span style="color:#66d9ef">of</span>
      <span style="color:#66d9ef">DEFAULT</span> <span style="color:#f92672">-&gt;</span>
        exit eta
      <span style="color:#ae81ff">1</span> <span style="color:#f92672">-&gt;</span>
        <span style="color:#f92672">...</span>
        <span style="color:#66d9ef">let</span>
          ipv <span style="color:#f92672">=</span>
            <span style="color:#f92672">+#</span> o<span style="color:#f92672">#</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">in</span>
          <span style="color:#f92672">...</span>
</code></pre></div><p>We can also make the distinction between lazy and strict values. When we see a <code>let</code>, this is a lazy variable declaration, whereas a <code>let!</code> signifies a strict variable declaration. We can spot code where values are lazily constructed and determine if that value doesn&rsquo;t actually need to be lazy. For example, the following code is lazy, but we should be able to determine it strictly. In theory, we should be able to find where the creation of <code>ipv</code> is in the surface program and then bang-pattern it, resulting in <code>let</code> becoming <code>let!</code> in the core program.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">  <span style="color:#66d9ef">let</span>
    ipv <span style="color:#f92672">=</span>
      <span style="color:#f92672">+#</span> o<span style="color:#f92672">#</span> <span style="color:#ae81ff">1</span>
</code></pre></div><p>This entire process is the general work flow when searching for optimisations by looking at Haskell core:</p>
<ul>
<li>Writing the program</li>
<li>Generating the core</li>
<li>Analysing the core to see if we are unhappy about how some code has been generated</li>
<li>Tweaking the way the code generates so that the ineffiency disappears. (If we are using staging, this means changing the code from the staging point-of-view.)</li>
</ul>
<p>If we are trying to determine what is causing slowness in a certain effect system, one thing that could be interesting to inspect is abstraction - if we have a lot of function calls that could have been inlined, or unwrapping and rewrapping of data structures.</p>
<p>Another thing to look out for is if we certain arguments haven&rsquo;t been unboxed when instead they could have been. Most types in GHC are boxed (values of that type are represented by a pointer to a heap object, e.g. the representation of <code>Int</code> is a two-word heap object). An unboxed type is represented by the value itself, no pointers or heap allocation is involved. These correspond to the &ldquo;raw machine&rdquo; types we would use in C. Most unboxed types end in the character <code>#</code>, e.g. <code>Int#</code>, <code>Double#</code>, <code>Addr#</code>, <code>(#, #)</code>. Similarly, the primitive operations on these types look like, for example, <code>&lt;#</code>, <code>+#</code>, <code>*#</code>.</p>
<p>To illustrate the consequence of boxed/unboxed types, consider the situation where we have a recursive call which takes an integer as an argument. If this integer had not been unboxed in the core, then the program would box the integer to the call of the recursive function; within the function it will then unbox the integer to do the work on it, and afterwards box up another integer as an argument to the recursive call. This is essentially a looping of unnecessarily boxing up and unboxing values.</p>
<p>The following code illustrates a recursive loop where the integer argument passed in (<code>o#</code>) is already successfully unboxed:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">  <span style="color:#66d9ef">let</span>
    rec
      loop <span style="color:#f92672">=</span>
        λo<span style="color:#f92672">#</span> eta <span style="color:#f92672">-&gt;</span>
          <span style="color:#f92672">...</span>
          loop (<span style="color:#f92672">+#</span> ipv <span style="color:#ae81ff">1</span>) s2<span style="color:#f92672">#</span>
</code></pre></div><p>So we are looking for constructors where we see a call to function wrap something up, and immediately on the other end of the function, wrap something up again. (This is something <code>monad-bayes</code> might be falling prey to).</p>
<p>As a helpful mindset, (if we were crazy) we could actually write the generated core code manually - we can look at this manual code and figure out what we can do to improve it ourselves. We then identify that we <em>could</em> have done something better, and wonder why hasn&rsquo;t the compiler done it. Getting the compiler to play ball is then the hard part - we have to convince the compiler that a certain optimisation is possible.</p>
<p>The canonical way of fixing performance issues in effect systems is removing the monad transformers and hand-rolling the entire instance. Although this is against the point of effect systems, at the same it can be very helpful. If we handroll the instance (which we can do by basically taking the monad transformed instances and inlining the definitions ourselves until we get to something primitive), we are essentially looking to see whether the core has generated that. This is a pattern of creating the ideal program, and working out which bits the compiler has missed out on that we have recognised. This is always a good approach when we don&rsquo;t understand what can be done better to the original program yet, and is a way to recognise and understand unfamiliar structures in core, such as <code>(#, #)</code>.</p>
<p>The relationship between the profiling information and the core, is more obvious than the relationship between the profiling information and the original code. We can use the profiler to guide us to the parts of the core that we want to look at.</p>
<p>Additionally, although memory leaks might not be what our performance issues are, they also could be. In Haskell, it&rsquo;s not called a memory leak, it&rsquo;s a space leak which is a bunch of unevaluated thunks which is causing a long chain of computation. The memory is held on to by the thunks even though it is potentially not used. If we see lots of heap activity, this could be a sign that laziness in our program is adding overhead. Also, if we are seeing a lot of objects being churned through (even if they are going through quite fast), we could ask &ldquo;are those objects necessary, or could they have been unboxed and thrown away?&rdquo;.</p>
<p>In the core visualisation, we also can highlight over certain fragments of code, and in the top right corner, this shows us the type information and also strictness properties. Even though something may appear to be lazy, we can identify that something is actually a strict binding (because it says <code>S</code> rather than <code>L</code>).</p>
<hr>
<p>Here&rsquo;s an example of when the generated core has inlined and eliminated all the <code>ST</code> occurrences. We have the following code:</p>
<p><img src="https://i.ibb.co/yVRgmJ3/image-35.png" alt=""></p>
<p><img src="https://i.ibb.co/R41yDnn/image-34.png" alt=""></p>
<p>So the reader monad should be milling around. This is <code>cata4</code>:</p>
<p><img src="https://i.ibb.co/R7rmRZ0/image-33.png" alt=""></p>
<p>And we have this function, <code>evalPush</code>:</p>
<p><img src="https://i.ibb.co/9c7cRVX/image-32.png" alt=""></p>
<p>But in the core, we can see the reader monad has been completely eliminated. There is no <code>fmap</code>, and no <code>IFunctor</code> instance from the <code>cata4</code> - it&rsquo;s just made as a recursive function.</p>
<p><img src="https://i.ibb.co/**Q**:d8wMS/image-31.png" alt=""></p>
<p>Here is another example - this involves <code>StateT + Reader</code></p>
<p><img src="https://i.ibb.co/GQMcmJY/image-30.png" alt=""></p>
<p>Let&rsquo;s go find this in the core and verify again the abstraction is gone.</p>
<p><img src="https://i.ibb.co/857R8BB/image-29.png" alt=""></p>
<p>Now there is that suspicious looking bit here:</p>
<p><img src="https://i.ibb.co/J7b77n6/image-28.png" alt=""></p>
<p>but the $s around here are indications of specialisation. We can visit these in this file and see what&rsquo;s up.</p>
<p><img src="https://i.ibb.co/P9TkzV6/image-27.png" alt=""></p>
<p>That&rsquo;s the code - it hasn&rsquo;t been marked as inline and it&rsquo;s quite big, so the compiler is probably reluctant to inline it (or specialise it a lot), but let&rsquo;s check the core:</p>
<p><img src="https://i.ibb.co/wWqJ0mP/image-26.png" alt=""></p>
<p>So it&rsquo;s unpacked the dictionary straight into the function. You can see that here:</p>
<p><img src="https://i.ibb.co/z2DM5Yr/image-25.png" alt=""></p>
<p>But it&rsquo;s not as optimised as it could have been (probably because it wasn&rsquo;t told it could specialise across the file boundary (this is defined in a different core dumped file)so it&rsquo;s optimised as much as it could generally but hasn&rsquo;t optimised it specifically to <code>StateT</code> as it could have done. That&rsquo;s a shame, but fixable easily (if JW cared about the internal library performance).</p>
<p>Now to go and check out the specialised applicative state functions!</p>
<p><img src="https://i.ibb.co/YfJhkYB/image-24.png" alt=""></p>
<p>It&rsquo;s created an app for <code>readerT + stateT</code>. We can see the <code>r1</code> from <code>reader</code>, and <code>s'</code> from <code>state</code> in there. There are no references to the original dictionaries, or indeed the original functions from either <code>ReaderT</code> or <code>StateT</code>.</p>
<p>The file is however, full of crap. There are a lot of dead specialised instances etc.</p>
<p>Here as well is a specialised <code>StateT + FreshT (&lt;*&gt;)</code>.</p>
<p><img src="https://i.ibb.co/J5gv9sg/image-23.png" alt=""></p>
<p>(CPS can be used to get rid of all the stupid tuples&hellip;)</p>
<p><strong>Q</strong>: Were any particular code changes necessary to ensure that the program specialised, e.g. there are cases of non-concrete monads <code>m</code> in type definitions, are any actions needed to make sure that GHC can work <code>m</code> out?</p>
<p><strong>A</strong>: Nope &ndash; GHC can specialise the monads when it sees them concretely then the inliner works its magic on the specialised code to form what we see there.
In the ideal, monads should be just as fast as the hand written equivalent.</p>
<p>The reason GHC left the <code>traverseCombinator</code> function alone, is because it wasn&rsquo;t marked with the <code>INLINABLE</code> pragma, so it doesn&rsquo;t have the code in the interface file (in other words, it doesn&rsquo;t know what it is in the other file). If we then chuck an <code>INLINABLE</code> pragma on it, let&rsquo;s see how it affects the core of the function we saw before:</p>
<p><img src="https://i.ibb.co/q5SXCkJ/image-21.png" alt=""></p>
<p>We can see that it still calls <code>traverseCombinator</code>, but it has an <code>$s</code> this time and there are no arguments passed to it. Let&rsquo;s take a peek inside:</p>
<p><img src="https://i.ibb.co/F5NNs3w/image-20.png" alt=""></p>
<p>Now the <code>reader</code> and <code>state</code> monad code has been inlined and optimised within this function. Interestingly, the specialiser wanted to specialise, but the inliner chose not to inline the <code>expose</code> parameter, which looks like this:</p>
<p><img src="https://i.ibb.co/JkcXtjH/image-19.png" alt=""></p>
<p>Another thing to notice is that, before when the <code>expose</code> parameter was left there, it made the code more complex than it needed to be (because the expose function used here is actually just <code>pure</code> roughly). After having marked <code>traverseCombinator</code> as <code>INLINE</code>,
it is inlined into the function, and the internals are simplified further. The <code>eta</code> is the reader context. We can obviously see that the state is being passed around happily - that&rsquo;s as optimal as it gets, and all GHC needed to go from the slower only-unwrapped version to this fully inlined and optimised version was an <code>INLINE</code> pragma.</p>
<p><img src="https://i.ibb.co/n**Q**:8HHf/image-18.png" alt=""></p>
<p>GHC has also done the same with the other use of <code>traverseCombinator</code>:</p>
<p><img src="https://i.ibb.co/LPMpN6Q/image-17.png" alt="">
<img src="https://i.ibb.co/rH5JCxf/image-16.png" alt="">
<img src="https://i.ibb.co/wKjY9HG/image-15.png" alt=""></p>
<p>The <code>$wg</code> function above is the <code>postprocess</code> function.</p>
<p>The moral of the story is: if we don&rsquo;t see <code>$w</code> or <code>$s</code> in the core anywhere, optimisations are not on.</p>
<ul>
<li><code>$w</code> is usually prepended to functions that the compiler as unwrapped some of the arguments for (eliminating a pattern match).</li>
<li><code>$s</code> is usually prepended to specialised functions.</li>
</ul>
<p>If we happen to inline a particular function and this results in a slower program, this implies that the code size is too big - so this leads to memory problems (cache issues). If the function isn&rsquo;t being optimised after it has been inlined, then it shouldn&rsquo;t be inlined.</p>
<p><strong>Q:</strong> Is it ever the case that you can undo an inline for some other function, and keep the new inline (which previously resulted in slower performance), so that it results in an overall better run-time?</p>
<p><strong>A:</strong> Yes. You can set the phase of the inliner. You can say &ldquo;inline past phase 2&rdquo; etc.</p>
<hr>
<h5 id="an-example-of-using-cps-in-parsley">An example of using CPS in Parsley</h5>
<p>Consider a program where we have the state monad in all different sorts of places, and we are unhappy with the building of the tuples being around.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">type</span> <span style="color:#66d9ef">State</span> s <span style="color:#f92672">=</span> <span style="color:#66d9ef">StateT</span> s <span style="color:#66d9ef">Identity</span>
<span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">StateT</span> s m a <span style="color:#f92672">=</span> <span style="color:#66d9ef">StateT</span> { runStateT <span style="color:#f92672">::</span> s <span style="color:#f92672">-&gt;</span> m (a, s) }
</code></pre></div><p>A good way to get rid of that is to use the continuation-passing-style form of the state monad.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">StateT</span> s m a <span style="color:#f92672">=</span> <span style="color:#66d9ef">StateT</span> { unStateT <span style="color:#f92672">::</span> forall r<span style="color:#f92672">.</span> s <span style="color:#f92672">-&gt;</span> (a <span style="color:#f92672">-&gt;</span> s <span style="color:#f92672">-&gt;</span> m r) <span style="color:#f92672">-&gt;</span> m r }
  <span style="color:#66d9ef">deriving</span> <span style="color:#66d9ef">Functor</span>
</code></pre></div><p>The translation we do is, we leave the result type <code>r</code> abstract, we take the state <code>s</code>, and then we take the function that consumes the <code>a</code> produced by this computation as well as the <code>s</code> in order to return the <code>m r</code>. This is actually the transformation we get when we apply the codensity transformation to state.</p>
<p>To run the state itself, we call <code>f</code> which is the function of type <code>forall r. s -&gt; (a -&gt; s -&gt; m r) -&gt; m r</code>, but we have to give it an argument of type <code>(a -&gt; s -&gt; m r)</code> as well as the initial state <code>s</code>. What we&rsquo;re looking for is an <code>a -&gt; s -&gt; m (a, s)</code> so that we can roughly recover <code>m (a, s)</code>. So the function we pass it is simply something that takes an <code>a</code> and <code>s</code> and calls <code>return</code> on the tuple <code>(a, s)</code> &ndash; so this is the final continuation that runs with the state.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">runStateT</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Monad</span> m <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">StateT</span> s m a <span style="color:#f92672">-&gt;</span> s <span style="color:#f92672">-&gt;</span> m (a, s)
<span style="color:#a6e22e">runStateT</span> (<span style="color:#66d9ef">StateT</span> f) s <span style="color:#f92672">=</span> f s (<span style="color:#a6e22e">\</span>x s&#39; <span style="color:#f92672">-&gt;</span> return (x, s&#39;))
</code></pre></div><p>Defining the actual instances of the CPS-form state monad is relatively okay after that point. We will find that the <code>m</code> never actually requires a monad constraint, because what we&rsquo;re actually doing all the time is building up continuations &ndash; we don&rsquo;t actually have to interact with the underlying monad <code>m</code> until we lift stuff into it (but most of the time, we are just feeding along continuations).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">instance</span> <span style="color:#66d9ef">Applicative</span> (<span style="color:#66d9ef">StateT</span> s m) <span style="color:#66d9ef">where</span>
  <span style="color:#75715e">{-# INLINE pure #-}</span>
  pure x <span style="color:#f92672">=</span> <span style="color:#66d9ef">StateT</span> (flip (<span style="color:#f92672">$</span> x))
  <span style="color:#75715e">{-# INLINE liftA2 #-}</span>
  liftA2 f (<span style="color:#66d9ef">StateT</span> mx) (<span style="color:#66d9ef">StateT</span> my) <span style="color:#f92672">=</span> <span style="color:#66d9ef">StateT</span> (<span style="color:#a6e22e">\</span>s k <span style="color:#f92672">-&gt;</span> mx s (<span style="color:#a6e22e">\</span>x s&#39; <span style="color:#f92672">-&gt;</span> my s&#39; (<span style="color:#a6e22e">\</span>y s&#39;&#39; <span style="color:#f92672">-&gt;</span> k (f x y) s&#39;&#39;)))

<span style="color:#66d9ef">instance</span> <span style="color:#66d9ef">Monad</span> (<span style="color:#66d9ef">StateT</span> s m) <span style="color:#66d9ef">where</span>
  <span style="color:#75715e">{-# INLINE return #-}</span>
  return <span style="color:#f92672">=</span> pure
  <span style="color:#75715e">{-# INLINE (&gt;&gt;=) #-}</span>
  <span style="color:#66d9ef">StateT</span> mx <span style="color:#f92672">&gt;&gt;=</span> f <span style="color:#f92672">=</span> <span style="color:#66d9ef">StateT</span> (<span style="color:#a6e22e">\</span>s k <span style="color:#f92672">-&gt;</span> mx s (<span style="color:#a6e22e">\</span>x s&#39; <span style="color:#f92672">-&gt;</span> unStateT (f x) s&#39; k))
</code></pre></div><p>The advantage is that given a monad with a data constructor containing n parameters, such as:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">Trace</span> a
  <span style="color:#f92672">=</span> <span style="color:#66d9ef">Trace</span>
      { variables <span style="color:#f92672">::</span> [<span style="color:#66d9ef">Double</span>],
        output <span style="color:#f92672">::</span> a,
        density <span style="color:#f92672">::</span> <span style="color:#66d9ef">Log</span> <span style="color:#66d9ef">Double</span>
      }
</code></pre></div><p>this becomes an n argument function.</p>
<p>For example with the <code>StateT</code> monad, this becomes a function where we say, here&rsquo;s the next thing along, <code>mx</code> :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">  <span style="color:#66d9ef">StateT</span> mx <span style="color:#f92672">&gt;&gt;=</span> f <span style="color:#f92672">=</span> <span style="color:#66d9ef">StateT</span> (<span style="color:#a6e22e">\</span>s k <span style="color:#f92672">-&gt;</span> mx
</code></pre></div><p>we provide it with the current parameters one after another (which in this case is just <code>s</code>) :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">  <span style="color:#66d9ef">StateT</span> mx <span style="color:#f92672">&gt;&gt;=</span> f <span style="color:#f92672">=</span> <span style="color:#66d9ef">StateT</span> (<span style="color:#a6e22e">\</span>s k <span style="color:#f92672">-&gt;</span> mx s
</code></pre></div><p>and once it&rsquo;s done (producing an <code>x</code>) :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">  <span style="color:#66d9ef">StateT</span> mx <span style="color:#f92672">&gt;&gt;=</span> f <span style="color:#f92672">=</span> <span style="color:#66d9ef">StateT</span> (<span style="color:#a6e22e">\</span>s k <span style="color:#f92672">-&gt;</span> mx s (<span style="color:#a6e22e">\</span>x
</code></pre></div><p>take all of the new parameters (which is just <code>s'</code>) :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">  <span style="color:#66d9ef">StateT</span> mx <span style="color:#f92672">&gt;&gt;=</span> f <span style="color:#f92672">=</span> <span style="color:#66d9ef">StateT</span> (<span style="color:#a6e22e">\</span>s k <span style="color:#f92672">-&gt;</span> mx s (<span style="color:#a6e22e">\</span>x s&#39;
</code></pre></div><p>and do what was meant to be done after the computation <code>k</code>, which is the <code>f</code> :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">  <span style="color:#66d9ef">StateT</span> mx <span style="color:#f92672">&gt;&gt;=</span> f <span style="color:#f92672">=</span> <span style="color:#66d9ef">StateT</span> (<span style="color:#a6e22e">\</span>s k <span style="color:#f92672">-&gt;</span> mx s (<span style="color:#a6e22e">\</span>x s&#39; <span style="color:#f92672">-&gt;</span> unStateT (f x) s&#39; k))
</code></pre></div><p>Very often, CPS is a good technique for optimisation. It doesn&rsquo;t always work, but it rarely makes things worse. The fact that we don&rsquo;t have to interact with the underlying monad means that the effect of the monad <code>m</code> in the <code>StateT s m</code> only gets ran when we use an operation from that monad. We can think of it as, the <code>StateT</code> computation is building that computation using continuations, so it doesn&rsquo;t need to interact with <code>m</code> at every step.</p>
<hr>
<ul>
<li>
<p>Q : Given a record data type such as:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">Trace</span> a
  <span style="color:#f92672">=</span> <span style="color:#66d9ef">Trace</span>
      {
        variables <span style="color:#f92672">::</span> [<span style="color:#66d9ef">Double</span>],
        output <span style="color:#f92672">::</span> a,
        density <span style="color:#f92672">::</span> <span style="color:#66d9ef">Log</span> <span style="color:#66d9ef">Double</span>
      }
</code></pre></div><p>is it unavoidable to lose the whole record feature (named parameters) if we were to optimise this to avoid the wrapping and rewrapping of the constructor</p>
</li>
<li>
<p>A : Nope! If it&rsquo;s strict and haskell can unbox it, you can still use the record syntax and record accessors &ndash; it&rsquo;s just they will get optimised out and replaced with just the relevant argument of the function directly.</p>
</li>
</ul>
<hr>
<h5 id="a-conversation-on-cpsing-datatypes">A Conversation on CPS&rsquo;ing Datatypes</h5>
<p><strong>MN</strong>: I&rsquo;m struggling a bit to work out what this (monadic) data type looks like in CPS-form, could you help me out?</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">Trace</span> a
  <span style="color:#f92672">=</span> <span style="color:#66d9ef">Trace</span>
      { variables <span style="color:#f92672">::</span> [<span style="color:#66d9ef">Double</span>],
        output    <span style="color:#f92672">::</span> a,
        density   <span style="color:#f92672">::</span> (<span style="color:#66d9ef">Log</span> <span style="color:#66d9ef">Double</span>)
      }
</code></pre></div><p><strong>JW</strong>:
What&rsquo;s the instance?</p>
<p><strong>MN</strong>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">instance</span> <span style="color:#66d9ef">Monad</span> <span style="color:#66d9ef">Trace</span> <span style="color:#66d9ef">where</span>
  t <span style="color:#f92672">&gt;&gt;=</span> f <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">let</span> t&#39; <span style="color:#f92672">=</span> f (output t)
     <span style="color:#66d9ef">in</span> t&#39; {variables <span style="color:#f92672">=</span> variables t <span style="color:#f92672">++</span> variables t&#39;, density <span style="color:#f92672">=</span> density t <span style="color:#f92672">*</span> density t&#39;}
</code></pre></div><p><strong>JW</strong>:
Thats a writer monad</p>
<p><strong>MN</strong>:
I wasn&rsquo;t aware that the instance mattered as well</p>
<p><strong>JW</strong>:
It helps me see what the semantics are.</p>
<p>This one is a weird one. I think this is it:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">Trace</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">Trace</span> { runTrace <span style="color:#f92672">::</span> forall r<span style="color:#f92672">.</span> ([<span style="color:#66d9ef">Double</span>] <span style="color:#f92672">-&gt;</span> a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Log</span> <span style="color:#66d9ef">Double</span> <span style="color:#f92672">-&gt;</span> r) <span style="color:#f92672">-&gt;</span> r }
</code></pre></div><hr>
<p><strong>MN</strong>:
I was looking back at your <code>StateT</code> CPS example, and i was wondering why there was an extra parameter <code>s</code> before the continuation:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">StateT</span> s m a <span style="color:#f92672">=</span> <span style="color:#66d9ef">StateT</span> { runStateT <span style="color:#f92672">::</span> s <span style="color:#f92672">-&gt;</span> m (a, s) }
<span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">StateT</span> s m a <span style="color:#f92672">=</span> <span style="color:#66d9ef">StateT</span> { runStateT <span style="color:#f92672">::</span> forall r<span style="color:#f92672">.</span> s <span style="color:#f92672">-&gt;</span> (a <span style="color:#f92672">-&gt;</span> s <span style="color:#f92672">-&gt;</span> m r) <span style="color:#f92672">-&gt;</span> m r}
</code></pre></div><p>I&rsquo;m just trying to grasp a general blueprint of CPS&rsquo;ing.</p>
<p><strong>JW</strong>:
That&rsquo;s the input. The inputs stay as inputs, the outputs get turned into a function, and then you can curry the function when otherwise you return a tuple.</p>
<p><strong>MN</strong>:
Is there a general rule for multiple constructor data types? For example, would:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">Either</span> a b <span style="color:#f92672">=</span> <span style="color:#66d9ef">Left</span> a <span style="color:#f92672">|</span> <span style="color:#66d9ef">Right</span> b
</code></pre></div><p>look like:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">Either</span> a b <span style="color:#f92672">=</span> <span style="color:#66d9ef">Either</span> { forall r<span style="color:#f92672">.</span> (a <span style="color:#f92672">-&gt;</span> b <span style="color:#f92672">-&gt;</span> r) <span style="color:#f92672">-&gt;</span> r}
</code></pre></div><p><strong>JW</strong>:
No, it can&rsquo;t. That implies that you have both results available at once, i.e. a product. For a coproduct, you have two continuations:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">Except</span> e a <span style="color:#f92672">=</span> <span style="color:#66d9ef">Except</span> { runExcept <span style="color:#f92672">::</span> forall r<span style="color:#f92672">.</span> (a <span style="color:#f92672">-&gt;</span> r) <span style="color:#f92672">-&gt;</span> (e <span style="color:#f92672">-&gt;</span> r) <span style="color:#f92672">-&gt;</span> r }
</code></pre></div><p><strong>MN</strong>:
Ooh i understand, thanks.</p>
<p><strong>JW</strong>:
So here&rsquo;s the same problem in reverse:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">ParsecT</span> m a <span style="color:#f92672">=</span> <span style="color:#66d9ef">ParsecT</span> { runParsecT <span style="color:#f92672">::</span> forall r<span style="color:#f92672">.</span> <span style="color:#66d9ef">String</span> <span style="color:#f92672">-&gt;</span> (<span style="color:#66d9ef">String</span> <span style="color:#f92672">-&gt;</span> a <span style="color:#f92672">-&gt;</span> m r) <span style="color:#f92672">-&gt;</span> (<span style="color:#66d9ef">String</span> <span style="color:#f92672">-&gt;</span> m r) <span style="color:#f92672">-&gt;</span> m r }
</code></pre></div><p>Can you figure out what the &ldquo;original&rdquo; datatype was?</p>
<p><strong>MN</strong>:
I&rsquo;m having a think, the input String and the multiple continuations together are confusing</p>
<p><strong>JW</strong>:
Perhaps break it into two parts then?</p>
<p><strong>MN</strong>:
I would&rsquo;ve thought that the original data type would contain a function <code>String -&gt; m (String, a)</code></p>
<p><strong>JW</strong>:
Ok, so that represents the <code>StateT</code> monad: <code>String -&gt; m (a, String)</code> is <code>StateT</code>.</p>
<p>So now let&rsquo;s factor that out:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">type</span> <span style="color:#66d9ef">ParsecT</span> m a <span style="color:#f92672">=</span> <span style="color:#66d9ef">StateT</span> (<span style="color:#66d9ef">Foo</span> m) a
<span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">Foo</span> m a <span style="color:#f92672">=</span> <span style="color:#66d9ef">Foo</span> { runFoo <span style="color:#f92672">::</span> forall r<span style="color:#f92672">.</span> (a <span style="color:#f92672">-&gt;</span> m r) <span style="color:#f92672">-&gt;</span> m r <span style="color:#f92672">-&gt;</span> m r }
</code></pre></div><p>Now, try to reverse engineer <code>Foo</code>.</p>
<p><strong>MN</strong>:
Alright, now that&rsquo;s confusing because there&rsquo;s an input after the continuation</p>
<p><strong>JW</strong>:
It&rsquo;s not an input ;). Does this help:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">Foo</span> m a <span style="color:#f92672">=</span> <span style="color:#66d9ef">Foo</span> { runFoo <span style="color:#f92672">::</span> forall r<span style="color:#f92672">.</span> (a <span style="color:#f92672">-&gt;</span> m r) <span style="color:#f92672">-&gt;</span> (() <span style="color:#f92672">-&gt;</span> m r) <span style="color:#f92672">-&gt;</span> m r }
</code></pre></div><p><strong>MN</strong>:
Right, so something like:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">Foo</span> m a <span style="color:#f92672">=</span> <span style="color:#66d9ef">Foo</span> (m a) <span style="color:#f92672">|</span> <span style="color:#66d9ef">Bar</span>
</code></pre></div><p><strong>JW</strong>:
Yep, or, in other words: <code>MaybeT</code>.</p>
<p>So now you have:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">type</span> <span style="color:#66d9ef">ParsecT</span> m a <span style="color:#f92672">=</span> <span style="color:#66d9ef">StateT</span> <span style="color:#66d9ef">String</span> (<span style="color:#66d9ef">MaybeT</span> m) a
</code></pre></div><p>or rather:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">ParsecT</span> m a <span style="color:#f92672">=</span> <span style="color:#66d9ef">ParsecT</span> { runParser <span style="color:#f92672">::</span> <span style="color:#66d9ef">String</span> <span style="color:#f92672">-&gt;</span> m (<span style="color:#66d9ef">Maybe</span> (a, <span style="color:#66d9ef">String</span>)) }
</code></pre></div><p><strong>MN</strong>:
Ohh, that&rsquo;s so complex - how that second continuation comes in is wacky</p>
<p><strong>JW</strong>:
You can conceptualise it as two outcomes: either the parser succeeds, or the parser fails.
Those represent the two branches of the maybe.</p>
<p>In reality, the real parsec has 4 continuations:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">type</span> <span style="color:#66d9ef">Parsec</span> a <span style="color:#f92672">=</span> forall r<span style="color:#f92672">.</span> <span style="color:#66d9ef">String</span> <span style="color:#f92672">-&gt;</span> (<span style="color:#66d9ef">String</span> <span style="color:#f92672">-&gt;</span> a <span style="color:#f92672">-&gt;</span> r) <span style="color:#f92672">-&gt;</span> (a <span style="color:#f92672">-&gt;</span> r) <span style="color:#f92672">-&gt;</span> (<span style="color:#66d9ef">String</span> <span style="color:#f92672">-&gt;</span> r) <span style="color:#f92672">-&gt;</span> r <span style="color:#f92672">-&gt;</span> r
</code></pre></div><p>One for success consuming input, one for success not consuming input, one for failure consuming input, and one for failure not consuming input.</p>
<p><strong>MN</strong>:
I see, so multiple continuations can represent either multiple constructors, or a nesting of monad transformers?</p>
<p><strong>JW</strong>:
The multiple continuations represent multiple constructors, or rather, multiple paths. It can mean that the nested monad has multiple branches itself, which is the case here, but all composed monads form their own unique monad.</p>
<p><strong>MN</strong>:
This is great stuff, thanks a lot!</p>
<p><strong>JW</strong>:
Just don&rsquo;t be tempted to transform List, or any recursive type for that matter. It&rsquo;s an infinite type unless you use Fix.</p>
<hr>
<p><strong>MN</strong>:
I&rsquo;m seeing two different versions of what the result <code>r</code> is when CPS&rsquo;ing data types, for instance:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">Maybe</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">Maybe</span> { runMaybe <span style="color:#f92672">::</span> forall r<span style="color:#f92672">.</span> (a <span style="color:#f92672">-&gt;</span> r) <span style="color:#f92672">-&gt;</span> r}
</code></pre></div><p>and</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">Maybe</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">Maybe</span> { runMaybe <span style="color:#f92672">::</span> forall r<span style="color:#f92672">.</span> (a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Maybe</span> r) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Maybe</span> r}
</code></pre></div><p>Are either/both correct?</p>
<p><strong>JW</strong>:
Neither is correct. They are both missing the <code>Nothing</code> continuation. However, the first is more correct. The second is technically more correct without the second continuation, but is far too strong. We want the <code>r</code> to be as weak as possible. Your second one is the codensity maybe.</p>
<hr>
<p><strong>MN</strong>:
I was wondering about how to write the corresponding run functions for CPS data types - i understand your type definition for your CPS <code>StateT</code>, but i&rsquo;m not sure how to apply it to types such as <code>Maybe</code>. Here&rsquo;s my attempt:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">Maybe</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">Just</span> a <span style="color:#f92672">|</span> <span style="color:#66d9ef">Nothing</span>

<span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">MaybeCPS</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">MaybeCPS</span> { unMaybeCPS <span style="color:#f92672">::</span> forall r<span style="color:#f92672">.</span> (a <span style="color:#f92672">-&gt;</span> r) <span style="color:#f92672">-&gt;</span> (() <span style="color:#f92672">-&gt;</span> r) <span style="color:#f92672">-&gt;</span> r }

<span style="color:#a6e22e">runMaybeCPS</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">MaybeCPS</span> a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Maybe</span> a
<span style="color:#a6e22e">runMaybeCPS</span> m <span style="color:#f92672">=</span> (unMaybeCPS m) <span style="color:#66d9ef">Just</span> (<span style="color:#a6e22e">\</span>() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Nothing</span>)
</code></pre></div><p><strong>JW</strong>:
Yeah that&rsquo;s correct. Obviously you don&rsquo;t need the const <code>Nothing</code>. You can just remove the <code>()</code> from the type.</p>
<p><strong>MN</strong>:
Thanks, also, given your <code>runStateT</code> has type:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">runStateT</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Monad</span> m <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">StateT</span> s m a <span style="color:#f92672">-&gt;</span> s <span style="color:#f92672">-&gt;</span> m (a, s)
</code></pre></div><p>Would it also be valid to use the approach i&rsquo;ve done with Maybe and MaybeCPS? Making a function:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">runStateTCPS</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Monad</span> m <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">StateTCPS</span> s m a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">StateT</span> s m a
</code></pre></div><p><strong>JW</strong>:
Nah, <code>Maybe</code> is kinda incidental. You want the same type as before. The <code>runStateT</code> provides <code>(return . (,))</code> or something.</p>
<p><strong>MN</strong>:
Ah i see, so just for the cases where constructors don&rsquo;t contain functions? Such as:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">Trace</span> a
  <span style="color:#f92672">=</span> <span style="color:#66d9ef">Trace</span>
      { variables <span style="color:#f92672">::</span> [<span style="color:#66d9ef">Double</span>],
        output    <span style="color:#f92672">::</span> a,
        density   <span style="color:#f92672">::</span> (<span style="color:#66d9ef">Log</span> <span style="color:#66d9ef">Double</span>)
      }

<span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">TraceCPS</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">TraceCPS</span> { unTraceCPS <span style="color:#f92672">::</span> forall r<span style="color:#f92672">.</span> ([<span style="color:#66d9ef">Double</span>] <span style="color:#f92672">-&gt;</span> a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Log</span> <span style="color:#66d9ef">Double</span> <span style="color:#f92672">-&gt;</span> r) <span style="color:#f92672">-&gt;</span> r }

<span style="color:#a6e22e">runTraceCPS</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">TraceCPS</span> a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Trace</span> a
</code></pre></div><p><strong>JW</strong>:
If you want the <code>Trace</code> datatype to come out, then sure. Perhaps you&rsquo;re only interested in one of the outputs. Idk.</p>
<p><strong>MN</strong>:
I get it! thanks.</p>
<p><strong>JW</strong>:
Realistically you can provide anything, including the rest of your program if you wanted to eliminate the Trace datatype entirely..</p>
<hr>
<p><strong>MN</strong>:
I&rsquo;m having a difficult time defining the applicative instance for MaybeCPS:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">MaybeCPS</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">MaybeCPS</span> { unMaybeCPS <span style="color:#f92672">::</span> forall r<span style="color:#f92672">.</span> (a <span style="color:#f92672">-&gt;</span> r) <span style="color:#f92672">-&gt;</span> (() <span style="color:#f92672">-&gt;</span> r) <span style="color:#f92672">-&gt;</span> r }
</code></pre></div><p>I think i need a function of type:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">app</span> <span style="color:#f92672">::</span> ((a <span style="color:#f92672">-&gt;</span> r)      <span style="color:#f92672">-&gt;</span> (() <span style="color:#f92672">-&gt;</span> r) <span style="color:#f92672">-&gt;</span> r)
    <span style="color:#f92672">-&gt;</span> ((a <span style="color:#f92672">-&gt;</span> b <span style="color:#f92672">-&gt;</span> r) <span style="color:#f92672">-&gt;</span> (() <span style="color:#f92672">-&gt;</span> r) <span style="color:#f92672">-&gt;</span> r)
    <span style="color:#f92672">-&gt;</span> ((b <span style="color:#f92672">-&gt;</span> r)      <span style="color:#f92672">-&gt;</span> (() <span style="color:#f92672">-&gt;</span> r) <span style="color:#f92672">-&gt;</span> r)
</code></pre></div><p>but i&rsquo;ve no idea how to make that possible</p>
<p><strong>JW</strong>:
Again, I would get rid of the unit, but just intuitively:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">mf</span> <span style="color:#f92672">&lt;*&gt;</span> mx <span style="color:#f92672">=</span> <span style="color:#a6e22e">\</span>good bad <span style="color:#f92672">-&gt;</span> mf (<span style="color:#a6e22e">\</span>f <span style="color:#f92672">-&gt;</span> mx (<span style="color:#a6e22e">\</span>x <span style="color:#f92672">-&gt;</span> good (f x)) bad) bad
</code></pre></div><p>That&rsquo;ll do it.</p>
<p><strong>MN</strong>:
I&rsquo;m just including the second continuation so i can see how this idea would apply to data types with multiple continuations</p>
<p><strong>JW</strong>:
The second continuation is still a continuation without the <code>()</code> because it&rsquo;s lazy.
<code>() =&gt; a</code> is iso to <code>a</code> in a lazy language. In a strict language you&rsquo;d have to use <code>() =&gt; a</code> (like scalas <code>=&gt;A</code> type).</p>
<p>You gave me the type of <code>&gt;&gt;=</code> above though, which is this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">mx</span> <span style="color:#f92672">&gt;&gt;=</span> f <span style="color:#f92672">=</span> <span style="color:#a6e22e">\</span>good bad <span style="color:#f92672">-&gt;</span> mx (<span style="color:#a6e22e">\</span>x <span style="color:#f92672">-&gt;</span> f x good bad) bad
</code></pre></div><hr>
<p><strong>MN</strong>:
So, i&rsquo;m trying to redefine this function in terms of TraceCPS (which is essentially the writer monad), but it&rsquo;s looking unbelievably awkward because m itself isn&rsquo;t in CPS form:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">bind</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Monad</span> m <span style="color:#f92672">=&gt;</span> m (<span style="color:#66d9ef">Trace</span> a) <span style="color:#f92672">-&gt;</span> (a <span style="color:#f92672">-&gt;</span> m (<span style="color:#66d9ef">Trace</span> b)) <span style="color:#f92672">-&gt;</span> m (<span style="color:#66d9ef">Trace</span> b)
<span style="color:#a6e22e">bind</span> dx f <span style="color:#f92672">=</span> <span style="color:#66d9ef">do</span>
  t1 <span style="color:#f92672">&lt;-</span> dx
  t2 <span style="color:#f92672">&lt;-</span> f (output t1)
  return <span style="color:#f92672">$</span> t2 {variables <span style="color:#f92672">=</span> variables t1 <span style="color:#f92672">++</span> variables t2, density <span style="color:#f92672">=</span> density t1 <span style="color:#f92672">*</span> density t2}
</code></pre></div><p>Is there a nice way of doing this?</p>
<p><strong>JW</strong>:
Huh? Why not <code>mT Trace a</code> or <code>TraceT m a</code></p>
<p><strong>MN</strong>:
Shit you&rsquo;re right</p>
<p><strong>JW</strong>:
I think you want <code>TraceT</code> as it happens</p>
<p><strong>MN</strong>:
I&rsquo;m also guessing that it&rsquo;s not possible to swap two arbitrary monads, i.e. a generalised <code>sequence</code>?</p>
<p><strong>JW</strong>:
No, the order of composition matters. <code>StateT s []</code> is not the same as <code>ListT (State s)</code> &ndash; one is localised state, the other is global state. In other words: <code>s -&gt; [(a, s)]</code> vs <code>s -&gt; ([a], s)</code></p>
<hr>
<p><strong>MN</strong>:
So, i obviously don&rsquo;t expect you to look at all of this, but is this the general transformation i should expect when handling arbitrary monads m inside of a CPS-form monad transformer?</p>
<p><img src="https://i.ibb.co/VHB5DFc/mhtrans.png" alt=""></p>
<p>i.e. will there will inevitably be some block of normal monad work? I don&rsquo;t know if that question makes sense, i&rsquo;m just not too confident about how the rest of my program should transform to accommodate the introduction of a CPS&rsquo;d monad.</p>
<p><strong>JW</strong>:
It shouldn&rsquo;t need to accomodate it at all if you&rsquo;ve done it right. You can substitute a monad in for its CPS form without any changes. Like, you&rsquo;re passing in a <code>TraceCPS a</code> in there &ndash; I don&rsquo;t expect that. The original trace data should be passed in at point of <code>runTrace</code>.</p>
<p><strong>MN</strong>:
Hmm, this might be the situation of me trying to convert functions which are already designed silly.</p>
<p><strong>JW</strong>:
Your <code>mhTrace</code> is weird.</p>
<p><strong>MN</strong>:
Yeah, that was the existing function found in monad-bayes.</p>
<p><strong>JW</strong>:
It starts with a trace, and ends in another monad that returns a trace, the whole thing should just be a <code>TraceT m a</code> computation. Then you provide the initial configuration by running that if you wanted.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">runTraceT</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">TraceCPST</span> m a <span style="color:#f92672">-&gt;</span> m (<span style="color:#66d9ef">Trace</span> a)
</code></pre></div><p>is something you can do. The input trace is a little weird because that implies it is more of a state than a writer.</p>
<p>It might be that <code>Trace</code> is used more like <code>State</code>, in which case <code>runTraceT :: TraceCPST m a -&gt; Trace a -&gt; m (Trace a)</code> is a more acceptable type.</p>
<hr>
<p><strong>MN</strong>:
Could i double-check with you whether my translation of <code>mapStateT</code> to CPS is correct? i&rsquo;ve had to introduce a <code>Monad m, Monad n</code> constraint, which i&rsquo;m not sure is right:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">mapStateT</span> <span style="color:#f92672">::</span> (m (a, s) <span style="color:#f92672">-&gt;</span> n (b, s)) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">StateT</span> s m a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">StateT</span> s n b
<span style="color:#a6e22e">mapStateT</span> f m <span style="color:#f92672">=</span> <span style="color:#66d9ef">StateT</span> <span style="color:#f92672">$</span> f <span style="color:#f92672">.</span> runStateT m

<span style="color:#a6e22e">mapStateT</span> <span style="color:#f92672">::</span> (<span style="color:#66d9ef">Monad</span> m, <span style="color:#66d9ef">Monad</span> n) <span style="color:#f92672">=&gt;</span> (m (a, s) <span style="color:#f92672">-&gt;</span> n (b, s)) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">StateT</span> s m a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">StateT</span> s n b
<span style="color:#a6e22e">mapStateT</span> f m <span style="color:#f92672">=</span> <span style="color:#66d9ef">StateT</span> (<span style="color:#a6e22e">\</span>s k <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">do</span> (b, s&#39;) <span style="color:#f92672">&lt;-</span> f <span style="color:#f92672">$</span> (runStateT m) s
                                   k b s&#39; )
</code></pre></div><p><strong>JW</strong>:
Nothing intrinsically wrong with what you&rsquo;ve done I don&rsquo;t think.
The Monad n constraint used to be in the &raquo;= , so it has to move somewhere. Both <code>m</code> and <code>n</code> have to be monads.</p>
<p><strong>MN</strong>:
This is interesting, i wonder if this has any performance impacts compared to the original <code>mapStateT</code>?</p>
<p><strong>JW</strong>:
Doubt it &ndash; it&rsquo;s all amortized because the <code>&gt;&gt;=</code> you&rsquo;ve introduced in <code>n</code> would have materialised somewhere else instead. You save binds in the CPS form, you don&rsquo;t introduce them, except in one specific case where it introduces 1 which is if you immediately run out <code>n</code> after this computation.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">runN</span> <span style="color:#f92672">.</span> runStateT s <span style="color:#f92672">.</span> mapStateT f <span style="color:#f92672">=</span> runN <span style="color:#f92672">.</span> f <span style="color:#f92672">.</span> runStateT s
</code></pre></div><p>The left-hand side has 1 bind the right does not.</p>
<p><strong>MN</strong>:
Is it important to keep <code>runStateT</code> out of intermediate computations then?</p>
<p><strong>JW</strong>:
It&rsquo;s not <code>runStateT</code>&rsquo;s fault, but yes, you should because it introduces redundant <code>return</code>s.</p>
<p><strong>MN</strong>:
I see, is this unavoidable in <code>mapStateT</code>?</p>
<p><strong>JW</strong>:
It is, but <code>return</code> is cheap. The equality on both sides of the equation:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">runN</span> <span style="color:#f92672">.</span> runStateT s <span style="color:#f92672">.</span> mapStateT f <span style="color:#f92672">=</span> runN <span style="color:#f92672">.</span> f <span style="color:#f92672">.</span> runStateT s
</code></pre></div><p>by the way boils down to this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">mx</span> <span style="color:#f92672">&gt;&gt;=</span> return <span style="color:#f92672">=</span> mx
</code></pre></div><p>They are equal because of that monad law, but the left hand side has the bind, and the right hand side does not.</p>
<p>The <code>&gt;&gt;=</code> is introduced by the <code>mapStateT</code> and the <code>return</code> by the <code>runStateT</code>. They should ideally cancel out, which is what happens on the right hand side.</p>
<hr>
<p><strong>MN</strong>:
If i were looking to turn most of my monads into CPS-form, could i literally just throw the <code>Cont</code> monad on them and expect an improvement in performance?</p>
<p><strong>JW</strong>:
<code>Cont</code> is the wrong monad, you mean <code>Cod</code>. But in general, <code>Cod</code> can be a good strategy.</p>
<p><strong>MN</strong>:
Oh, i haven&rsquo;t learned about the codensity monad.</p>
<p><strong>JW</strong>:
It&rsquo;s like <code>Cont</code> but no <code>r</code>, which should feel familar.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">ContT</span> r m a <span style="color:#f92672">=</span> <span style="color:#66d9ef">ContT</span> ((a <span style="color:#f92672">-&gt;</span> m r) <span style="color:#f92672">-&gt;</span> m r)

<span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">Cod</span> m a <span style="color:#f92672">=</span> <span style="color:#66d9ef">Cod</span> (forall r<span style="color:#f92672">.</span> (a <span style="color:#f92672">-&gt;</span> m r) <span style="color:#f92672">-&gt;</span> m r)
</code></pre></div><p><code>Cod</code> is the difference list for monads &ndash; it ensures that all <code>&gt;&gt;=</code> are right associated.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">Cod</span> (<span style="color:#66d9ef">StateT</span> s m) a <span style="color:#f92672">~=</span> <span style="color:#66d9ef">StateCPST</span> s m a
</code></pre></div><p>but the right hand side is more efficient - you&rsquo;ll find it has no monad constraints just like yours don&rsquo;t.</p>
<p><strong>MN</strong>:
Why would one ever use the <code>ContT</code> monad if <code>Cod</code> exists &ndash; i&rsquo;m having difficulty understanding what one achieves over the other.</p>
<p><strong>JW</strong>:
They don&rsquo;t do the same thing. <code>ContT</code> makes progress towards a known <code>r</code>. You&rsquo;ll notice there is no <code>CodT</code> &ndash; <code>Cod</code> is intrinsically tied to another monad and has no <code>callCC</code> operation.</p>
<hr>
<p><strong>MN</strong>:
I&rsquo;m having an issue when trying to define a CPS version of <code>liftPass</code> (the bottom version doesn&rsquo;t compile - i&rsquo;m not sure what i&rsquo;m supposed to do with the <code>f</code>).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">liftPass</span> <span style="color:#f92672">::</span> (<span style="color:#66d9ef">Monad</span> m) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">Pass</span> w m (a,s) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Pass</span> w (<span style="color:#66d9ef">StateT</span> s m) a
<span style="color:#a6e22e">liftPass</span> pass m <span style="color:#f92672">=</span> <span style="color:#66d9ef">StateT</span> <span style="color:#f92672">$</span> <span style="color:#a6e22e">\</span> s <span style="color:#f92672">-&gt;</span> pass <span style="color:#f92672">$</span> <span style="color:#66d9ef">do</span>
    <span style="color:#f92672">~</span>((a, f), s&#39;) <span style="color:#f92672">&lt;-</span> runStateT m s
    return ((a, s&#39;), f)

<span style="color:#a6e22e">liftPass</span> <span style="color:#f92672">::</span> (<span style="color:#66d9ef">Monad</span> m) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">Pass</span> w m (a,s) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Pass</span> w (<span style="color:#66d9ef">StateT</span> s m) a
<span style="color:#a6e22e">liftPass</span> pass m <span style="color:#f92672">=</span> <span style="color:#66d9ef">StateT</span> <span style="color:#f92672">$</span> <span style="color:#a6e22e">\</span>s k <span style="color:#f92672">-&gt;</span> pass <span style="color:#f92672">$</span> <span style="color:#66d9ef">do</span>
    <span style="color:#f92672">~</span>((a, f), s&#39;) <span style="color:#f92672">&lt;-</span> runStateT m s
    k (a, s&#39;) f
</code></pre></div><p><strong>JW</strong>:
What is <code>Pass</code>?</p>
<p><strong>MN</strong>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">type</span> <span style="color:#66d9ef">Pass</span> w m a <span style="color:#f92672">=</span>  m (a, w <span style="color:#f92672">-&gt;</span> w) <span style="color:#f92672">-&gt;</span> m a
</code></pre></div><p><strong>JW</strong>:
Let&rsquo;s start with this non mangled function:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">liftPass</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">MonadWriter</span> w m <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">StateT</span> s (a, w <span style="color:#f92672">-&gt;</span> w) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">StateT</span> s a
<span style="color:#a6e22e">liftPass</span> m <span style="color:#f92672">=</span> <span style="color:#66d9ef">StateT</span> <span style="color:#f92672">$</span> <span style="color:#a6e22e">\</span> s <span style="color:#f92672">-&gt;</span> pass <span style="color:#f92672">$</span> <span style="color:#66d9ef">do</span>
    ((a, f), s&#39;) <span style="color:#f92672">&lt;-</span> runStateT m s
    return ((a, s&#39;), f)
</code></pre></div><p>Got it</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">pass</span> (<span style="color:#66d9ef">StateT</span> mx) <span style="color:#f92672">=</span> <span style="color:#66d9ef">StateT</span> <span style="color:#f92672">$</span> <span style="color:#a6e22e">\</span> s k <span style="color:#f92672">-&gt;</span>
    pass (mx s (<span style="color:#a6e22e">\</span>(x, f) s&#39; <span style="color:#f92672">-&gt;</span> return ((x, s&#39;), f))) <span style="color:#f92672">&gt;&gt;=</span> uncurry k
</code></pre></div><p>I&rsquo;ve not used <code>runStateT</code> here because it gets wrapped up in another return anyway, so no point in doing return <code>((a, f), s) &gt;&gt;= \((a, f), s) -&gt; return ((a, s), f)</code> &ndash; completely redundant.</p>
<p>I&rsquo;ll write it in words:</p>
<p>Take <code>mx</code>, feed it the state <code>s</code> and you will get <code>(x, f)</code> out of it along with a new state <code>s'</code>, these can be fed to a continuation (as opposed to using <code>runStateT</code>, which repackages them into a form that <code>pass</code> accepts. This produces a <code>m (a, s)</code> which we can bind on using <code>uncurry k</code> as the next step.</p>
<p>So you were close, just put the <code>pass</code> in the wrong place &ndash; at least, I think so.</p>
<p>It&rsquo;s really hard to tell with operations like this &ndash; lots of wrong things type check. Like it also type checks if you put the pass inside the continuation for <code>mx</code>. It also type checks if you put the <code>&gt;&gt;= uncurry k</code> in there as well, but I think that changes the meaning slightly.</p>
<p>I think the key here is by putting the <code>pass</code> inside the continuation to <code>mx</code>, you make <code>pass</code>&rsquo;s effect happen to the <code>return</code>, which always applies <code>f</code> to the <code>mempty</code>.</p>
<p>That&rsquo;s probably not what you wanted, so best to run out the entire computation first.
I think <code>local</code> from <code>reader</code> is another annoying one. Though they use <code>mapStateT</code> for that.</p>
<hr>
<p><strong>JW</strong>:
There&rsquo;s a couple of things at play with the CPS monads</p>
<p>The first is that you&rsquo;re removing allocations of tuples and intermediate structures.The second is that you&rsquo;re reassociating the binds into what may be their optimised form (but at worst it isn&rsquo;t any more expensive).</p>
<p>By the way, did you replace your TraceCPS by the State? Or is it a complement?</p>
<p><strong>MN</strong>:
I haven&rsquo;t, i just replaced the Control.Monad.Trans.State with the State</p>
<p><strong>MN</strong>:
by the way, im a bit confused, what you did with <code>StateT</code> was CPS right? Thy did you suggest using the Codensity monad yesterday</p>
<p><strong>JW</strong>:
I didn&rsquo;t, you mentioned <code>ContT</code> and I said that&rsquo;s the wrong abstraction. <code>Cod</code> accomplishes the second aim of the CPS &ndash; the reassociation into the optimised direction
(which may or may not produce an improvement). But fully CPSing is how we can remove the allocations and get the best performance out because it physically changes the make up.</p>
<p>Like:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">   <span style="color:#66d9ef">Cod</span> (<span style="color:#66d9ef">StateT</span> s m) a
<span style="color:#f92672">~=</span> forall r<span style="color:#f92672">.</span> (a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">StateT</span> s m r) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">StateT</span> s m r
<span style="color:#f92672">~=</span> forall r<span style="color:#f92672">.</span> (a <span style="color:#f92672">-&gt;</span> s <span style="color:#f92672">-&gt;</span> m (r, s)) <span style="color:#f92672">-&gt;</span> s <span style="color:#f92672">-&gt;</span> m (r, s)
</code></pre></div><p>You can see that&rsquo;s not the same as:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">forall</span> r<span style="color:#f92672">.</span> (a <span style="color:#f92672">-&gt;</span> s <span style="color:#f92672">-&gt;</span> m r) <span style="color:#f92672">-&gt;</span> m r
</code></pre></div><p>It&rsquo;s very close though.</p>
<p><strong>MN</strong>:
Ah, yep i see! So the <code>Cod</code> still requires the use of <code>StateT</code> in that.</p>
<p><strong>JW</strong>:
<code>Cod</code> is a cheap dirty CPS &ndash; good in a pinch, but doing it by hand will yield better results.</p>
<p><strong>MN</strong>:
I haven&rsquo;t learned about reassociation of binds and their optimisations before.</p>
<p><strong>JW</strong>:
It&rsquo;s clear from this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">(mx <span style="color:#f92672">&gt;&gt;=</span> f) <span style="color:#f92672">&gt;&gt;=</span> g <span style="color:#f92672">=</span> m <span style="color:#f92672">&gt;&gt;=</span> (<span style="color:#a6e22e">\</span>x <span style="color:#f92672">-&gt;</span> f x <span style="color:#f92672">&gt;&gt;=</span> g)
</code></pre></div><p>Now consider when <code>mx = Nothing</code>.</p>
<p>The left hand side evaluates using two steps:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">  (<span style="color:#66d9ef">Nothing</span> <span style="color:#f92672">&gt;&gt;=</span> f) <span style="color:#f92672">&gt;&gt;=</span> g
<span style="color:#f92672">=</span> <span style="color:#66d9ef">Nothing</span> <span style="color:#f92672">&gt;&gt;=</span> g
<span style="color:#f92672">=</span> <span style="color:#66d9ef">Nothing</span>
</code></pre></div><p>The right hand side evalutes using one step:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">  <span style="color:#66d9ef">Nothing</span> <span style="color:#f92672">&gt;&gt;=</span> (<span style="color:#a6e22e">\</span>x <span style="color:#f92672">-&gt;</span> f x <span style="color:#f92672">&gt;&gt;=</span> g)
<span style="color:#f92672">=</span> <span style="color:#66d9ef">Nothing</span>
</code></pre></div><p>The left association of binds can cause an O(n^2) blowup, similar to how left associated <code>++</code> is problematic. This is talked about in <a href="../../papers/freer-monads/#27-performance-problem-of-freeer-monads">freer-monads</a>.</p>
<p><code>Cod</code> is to monads as difference lists are to lists</p>
<p><strong>MN</strong>:
I understand, so a big build up in evaluation steps needed! Would you recommend CPS&rsquo;ing other common monads used, such as <code>Writer</code>, <code>Reader</code> (or maybe even <code>ListT</code> using <code>Fix</code>, if i figure out how thats done)?</p>
<p><strong>JW</strong>:
<code>Reader</code> is already in CPS</p>
<p>I hope you&rsquo;re not using ListT m a = m [a] !</p>
<ul>
<li><strong>MN</strong>: Err, the <code>Control.Monad.Trans.List</code> one, so <code>newtype ListT m a = ListT {runListT :: m [a] }</code></li>
<li><strong>JW</strong>: Ah yeah that&rsquo;s what I meant &ndash; it&rsquo;s technically problematic. But I think it&rsquo;s major shortcomings might be with IO, I&rsquo;m not sure. You should probably be using <code>LogicT</code>.</li>
<li><strong>MN</strong>: Is <code>LogicT</code> a better alternative in terms of correctness, or performance?</li>
<li><strong>JW</strong>: Correctness.</li>
</ul>
<p><strong>JW</strong>:
I wouldn&rsquo;t recommend the CPS&rsquo;ing the <code>List</code> one anyway, you basically create a cascading tower of continuations. It&rsquo;s not pretty even if you get it working.</p>
<p>CPS&rsquo;ing <code>Writer</code> on the other hand, is a good bet. However, just using <code>Cod</code> on <code>Writer</code> might help, or ensuring the monoid is optimised properly &ndash; i.e. using the Difference List monoid instead of lists, for instance.</p>
<p><strong>MN</strong>:
I haven&rsquo;t heard of difference lists before, i&rsquo;ll do some reading.</p>
<p><strong>JW</strong>:
It&rsquo;s a simple idea:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">DList</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">DList</span> ([a] <span style="color:#f92672">-&gt;</span> [a])

<span style="color:#a6e22e">fromList</span> <span style="color:#f92672">::</span> [a] <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">DList</span> a
<span style="color:#a6e22e">fromList</span> <span style="color:#f92672">=</span> (<span style="color:#f92672">++</span>)

<span style="color:#a6e22e">toList</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">DList</span> a <span style="color:#f92672">-&gt;</span> [a]
<span style="color:#a6e22e">toList</span> <span style="color:#f92672">=</span> (<span style="color:#f92672">$</span> <span style="color:#66d9ef">[]</span>)

<span style="color:#66d9ef">instance</span> <span style="color:#66d9ef">Monoid</span> (<span style="color:#66d9ef">DList</span> a) <span style="color:#66d9ef">where</span>
  mempty <span style="color:#f92672">=</span> <span style="color:#66d9ef">DList</span> id
  <span style="color:#66d9ef">DList</span> xs <span style="color:#f92672">&lt;&gt;</span> <span style="color:#66d9ef">DList</span> ys <span style="color:#f92672">=</span> <span style="color:#66d9ef">DList</span> (xs <span style="color:#f92672">.</span> ys)

<span style="color:#a6e22e">cons</span> <span style="color:#f92672">::</span> a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">DList</span> a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">DList</span> a
<span style="color:#a6e22e">cons</span> x (<span style="color:#66d9ef">DList</span> xs) <span style="color:#f92672">=</span> <span style="color:#66d9ef">DList</span> ((x <span style="color:#66d9ef">:</span>) <span style="color:#f92672">.</span> xs)
</code></pre></div><p>Then if you have:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">(fromList [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>] <span style="color:#f92672">&lt;&gt;</span> fromList [<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>]) <span style="color:#f92672">&lt;&gt;</span> fromList [<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>]
</code></pre></div><p>Then this becomes right associated and optimal:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">  (([<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>] <span style="color:#f92672">++</span>) <span style="color:#f92672">.</span> ([<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>] <span style="color:#f92672">++</span>)) <span style="color:#f92672">.</span> ([<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>] <span style="color:#f92672">++</span>)
<span style="color:#f92672">=</span> ([<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>] <span style="color:#f92672">++</span>) <span style="color:#f92672">.</span> ([<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>] <span style="color:#f92672">++</span>) <span style="color:#f92672">.</span> ([<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>] <span style="color:#f92672">++</span>)

  toList (<span style="color:#66d9ef">DList</span> (([<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>] <span style="color:#f92672">++</span>) <span style="color:#f92672">.</span> ([<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>] <span style="color:#f92672">++</span>) <span style="color:#f92672">.</span> ([<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>] <span style="color:#f92672">++</span>)))
<span style="color:#f92672">=</span> (([<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>] <span style="color:#f92672">++</span>) <span style="color:#f92672">.</span> ([<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>] <span style="color:#f92672">++</span>) <span style="color:#f92672">.</span> ([<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>] <span style="color:#f92672">++</span>))) <span style="color:#66d9ef">[]</span>
<span style="color:#f92672">=</span> ([<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>] <span style="color:#f92672">++</span>) (([<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>] <span style="color:#f92672">++</span>) (([<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>] <span style="color:#f92672">++</span>) <span style="color:#66d9ef">[]</span>))
<span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>] <span style="color:#f92672">++</span> ([<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>] <span style="color:#f92672">++</span> ([<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>] <span style="color:#f92672">++</span> <span style="color:#66d9ef">[]</span>))
</code></pre></div><p>You can see how it relates to <code>Cod</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">(<span style="color:#f92672">++</span>) <span style="color:#f92672">::</span> [a] <span style="color:#f92672">-&gt;</span> ([a] <span style="color:#f92672">-&gt;</span> [a])
<span style="color:#66d9ef">DList</span> <span style="color:#f92672">=</span> [a] <span style="color:#f92672">-&gt;</span> [a]
(<span style="color:#f92672">&gt;&gt;=</span>) <span style="color:#f92672">::</span> m a <span style="color:#f92672">-&gt;</span> (a <span style="color:#f92672">-&gt;</span> m b) <span style="color:#f92672">-&gt;</span> m b
<span style="color:#66d9ef">Cod</span> <span style="color:#f92672">=</span> forall b<span style="color:#f92672">.</span> (a <span style="color:#f92672">-&gt;</span> m b) <span style="color:#f92672">-&gt;</span> m b
</code></pre></div><p>It&rsquo;s just partially apply the operation to the first argument, and leave the rest as the function. It&rsquo;s a trick you can pull for basically anything.</p>
<p>Here&rsquo;s something i&rsquo;ll bring your attention to:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">instance</span> <span style="color:#66d9ef">Show</span> (<span style="color:#66d9ef">Fix</span> <span style="color:#66d9ef">Combinator</span> a) <span style="color:#66d9ef">where</span>
  show <span style="color:#f92672">=</span> (<span style="color:#f92672">$</span> <span style="color:#e6db74">&#34;&#34;</span>) <span style="color:#f92672">.</span> getConst1 <span style="color:#f92672">.</span> cata (<span style="color:#66d9ef">Const1</span> <span style="color:#f92672">.</span> alg)
    <span style="color:#66d9ef">where</span>
      alg (<span style="color:#66d9ef">Pure</span> x)                                  <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;(pure &#34;</span> <span style="color:#f92672">.</span> shows x <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34;)&#34;</span>
      alg (<span style="color:#66d9ef">Satisfy</span> f)                               <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;(satisfy &#34;</span> <span style="color:#f92672">.</span> shows f <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34;)&#34;</span>
      alg (<span style="color:#66d9ef">Const1</span> pf <span style="color:#66d9ef">:&lt;*&gt;:</span> <span style="color:#66d9ef">Const1</span> px)               <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;(&#34;</span> <span style="color:#f92672">.</span> pf <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34; &lt;*&gt; &#34;</span> <span style="color:#f92672">.</span>  px <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34;)&#34;</span>
      alg (<span style="color:#66d9ef">Const1</span> p <span style="color:#66d9ef">:*&gt;:</span> <span style="color:#66d9ef">Const1</span> q)                  <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;(&#34;</span> <span style="color:#f92672">.</span> p <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34; *&gt; &#34;</span> <span style="color:#f92672">.</span> q <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34;)&#34;</span>
      alg (<span style="color:#66d9ef">Const1</span> p <span style="color:#66d9ef">:&lt;*:</span> <span style="color:#66d9ef">Const1</span> q)                  <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;(&#34;</span> <span style="color:#f92672">.</span> p <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34; &lt;* &#34;</span> <span style="color:#f92672">.</span> q <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34;)&#34;</span>
      alg (<span style="color:#66d9ef">Const1</span> p <span style="color:#66d9ef">:&lt;|&gt;:</span> <span style="color:#66d9ef">Const1</span> q)                 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;(&#34;</span> <span style="color:#f92672">.</span> p <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34; &lt;|&gt; &#34;</span> <span style="color:#f92672">.</span> q <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34;)&#34;</span>
      alg <span style="color:#66d9ef">Empty</span>                                     <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;empty&#34;</span>
      alg (<span style="color:#66d9ef">Try</span> (<span style="color:#66d9ef">Const1</span> p))                          <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;(try &#34;</span> <span style="color:#f92672">.</span> p <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34;)&#34;</span>
      alg (<span style="color:#66d9ef">LookAhead</span> (<span style="color:#66d9ef">Const1</span> p))                    <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;(lookAhead &#34;</span> <span style="color:#f92672">.</span> p <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34;)&#34;</span>
      alg (<span style="color:#66d9ef">Let</span> <span style="color:#66d9ef">False</span> v <span style="color:#66d9ef">_</span>)                           <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;(let-bound &#34;</span> <span style="color:#f92672">.</span> shows v <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34;)&#34;</span>
      alg (<span style="color:#66d9ef">Let</span> <span style="color:#66d9ef">True</span> v <span style="color:#66d9ef">_</span>)                            <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;(rec &#34;</span> <span style="color:#f92672">.</span> shows v <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34;)&#34;</span>
      alg (<span style="color:#66d9ef">NotFollowedBy</span> (<span style="color:#66d9ef">Const1</span> p))                <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;(notFollowedBy &#34;</span> <span style="color:#f92672">.</span> p <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34;)&#34;</span>
      alg (<span style="color:#66d9ef">Branch</span> (<span style="color:#66d9ef">Const1</span> b) (<span style="color:#66d9ef">Const1</span> p) (<span style="color:#66d9ef">Const1</span> q)) <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;(branch &#34;</span> <span style="color:#f92672">.</span> b <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">.</span> p <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">.</span> q <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34;)&#34;</span>
      alg (<span style="color:#66d9ef">Match</span> (<span style="color:#66d9ef">Const1</span> p) fs qs (<span style="color:#66d9ef">Const1</span> def))     <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;(match &#34;</span> <span style="color:#f92672">.</span> p <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">.</span> shows fs <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34; [&#34;</span> <span style="color:#f92672">.</span> intercalateDiff (<span style="color:#e6db74">&#34;, &#34;</span>) (map getConst1 qs) <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34;] &#34;</span>  <span style="color:#f92672">.</span> def <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34;)&#34;</span>
      alg (<span style="color:#66d9ef">ChainPre</span> (<span style="color:#66d9ef">Const1</span> op) (<span style="color:#66d9ef">Const1</span> p))         <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;(chainPre &#34;</span> <span style="color:#f92672">.</span> op <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">.</span> p <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34;)&#34;</span>
      alg (<span style="color:#66d9ef">ChainPost</span> (<span style="color:#66d9ef">Const1</span> p) (<span style="color:#66d9ef">Const1</span> op))        <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;(chainPost &#34;</span> <span style="color:#f92672">.</span> p <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">.</span> op <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34;)&#34;</span>
      alg (<span style="color:#66d9ef">MakeRegister</span> σ (<span style="color:#66d9ef">Const1</span> p) (<span style="color:#66d9ef">Const1</span> q))    <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;(make &#34;</span> <span style="color:#f92672">.</span> shows σ <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">.</span> p <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">.</span> q <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34;)&#34;</span>
      alg (<span style="color:#66d9ef">GetRegister</span> σ)                           <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;(get &#34;</span> <span style="color:#f92672">.</span> shows σ <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34;)&#34;</span>
      alg (<span style="color:#66d9ef">PutRegister</span> σ (<span style="color:#66d9ef">Const1</span> p))                <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;(put &#34;</span> <span style="color:#f92672">.</span> shows σ <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">.</span> p <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34;)&#34;</span>
      alg (<span style="color:#66d9ef">Debug</span> <span style="color:#66d9ef">_</span> (<span style="color:#66d9ef">Const1</span> p))                      <span style="color:#f92672">=</span> p
      alg (<span style="color:#66d9ef">MetaCombinator</span> m (<span style="color:#66d9ef">Const1</span> p))             <span style="color:#f92672">=</span> p <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34; [&#34;</span> <span style="color:#f92672">.</span> shows m <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34;]
</span></code></pre></div><p>I mean, this is magic, but same idea.</p>
<p>I had a <code>show</code> function for my ASTs, and I got a massive massive speedup by switching out all the <code>(++)</code> for <code>(.)</code>.</p>
<p>It&rsquo;s using overloaded strings:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">instance</span> <span style="color:#66d9ef">IsString</span> (<span style="color:#66d9ef">String</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">String</span>) <span style="color:#66d9ef">where</span>
  fromString <span style="color:#f92672">=</span> showString
</code></pre></div><p>where a string literal is actually the <code>showString</code> of that string literal.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">showString</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">String</span> <span style="color:#f92672">-&gt;</span> (<span style="color:#66d9ef">String</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">String</span>)
<span style="color:#a6e22e">shows</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Show</span> a <span style="color:#f92672">=&gt;</span> a <span style="color:#f92672">-&gt;</span> (<span style="color:#66d9ef">String</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">String</span>)
</code></pre></div><p>Overloaded strings lets me assign a new meaning for string literals &ndash; in this case, I give it the meaning of the difference list, because in this sort of instance, you can&rsquo;t control how the <code>(++)</code> associates; the left and the right branches of the AST will contain them.</p>
<p>Using the difference list it transforms it into a fully linear sequence of them, reducing the <code>show</code> instance down to linear time.</p>
<hr>
<p><strong>MN</strong>:
Would DListT look like:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">DListT</span> m a <span style="color:#f92672">=</span> <span style="color:#66d9ef">DListT</span> { runDListT <span style="color:#f92672">::</span> m [a] <span style="color:#f92672">-&gt;</span> m [a] }
</code></pre></div><p>There are a few versions online, and they&rsquo;re all using different designs/versions of ListT etc, its a bit confusing.</p>
<p><strong>JW</strong>:
A <code>DList</code> isn&rsquo;t a monad, so it&rsquo;s not a monad transformer, it&rsquo;s a Monoid.</p>
<p>You are probably after this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">LogicT</span> m a <span style="color:#f92672">=</span> <span style="color:#66d9ef">LogicT</span> { unLogicT <span style="color:#f92672">::</span> forall r<span style="color:#f92672">.</span> (a <span style="color:#f92672">-&gt;</span> m r <span style="color:#f92672">-&gt;</span> m r) <span style="color:#f92672">-&gt;</span> m r <span style="color:#f92672">-&gt;</span> m r}
</code></pre></div><p>It&rsquo;s already in CPS form for you!</p>
<p><strong>MN</strong>:
Whaaaat, so it already has the benefits of a <code>DList</code>?</p>
<p><strong>JW</strong>:
<code>DList</code> isn&rsquo;t for monadic computation, and <code>Cod</code> isn&rsquo;t for alternative computation.</p>
<p><a href="https://stackoverflow.com/questions/32252312/is-there-a-codensity-monadplus-that-asymptotically-optimizes-a-sequence-of-monad">https://stackoverflow.com/questions/32252312/is-there-a-codensity-monadplus-that-asymptotically-optimizes-a-sequence-of-monad</a></p>
<p><strong>MN</strong>:
I&rsquo;ll have a read; it looks like swapping from <code>ListT</code> to <code>LogicT</code> may be a difficult job - there aren&rsquo;t any corresponding list helper functions.</p>
<p><strong>JW</strong>:
Well, it&rsquo;s all about <code>&lt;|&gt;</code> &ndash; have a read of this too: <a href="http://okmij.org/ftp/papers/LogicT.pdf">http://okmij.org/ftp/papers/LogicT.pdf</a></p>
<p>I suspect nothing in your program changes, you use:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">observeAllT</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Monad</span> m <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">LogicT</span> m a <span style="color:#f92672">-&gt;</span> m [a]
</code></pre></div><p>You&rsquo;re no doubt using alternative and monadic operations on lists anyway.</p>
<p><strong>MN</strong>:
How would one replace the <code>ListT</code> constructor with the <code>LogicT</code> constructor given such a function as:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">ListT</span> m a <span style="color:#f92672">=</span> <span style="color:#66d9ef">ListT</span> { runListT <span style="color:#f92672">::</span> m [a] }

<span style="color:#a6e22e">fromWeightedList</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Monad</span> m <span style="color:#f92672">=&gt;</span> m [(a, <span style="color:#66d9ef">Log</span> <span style="color:#66d9ef">Double</span>)] <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">ListT</span> m a
<span style="color:#a6e22e">fromWeightedList</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">ListT</span>

<span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">LogicT</span> m a <span style="color:#f92672">=</span> <span style="color:#66d9ef">LogicT</span> { unLogicT <span style="color:#f92672">::</span> forall r<span style="color:#f92672">.</span> (a <span style="color:#f92672">-&gt;</span> m r <span style="color:#f92672">-&gt;</span> m r) <span style="color:#f92672">-&gt;</span> m r <span style="color:#f92672">-&gt;</span> m r }

<span style="color:#a6e22e">fromWeightedList</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Monad</span> m <span style="color:#f92672">=&gt;</span> m [(a, <span style="color:#66d9ef">Log</span> <span style="color:#66d9ef">Double</span>)] <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">LogicT</span> m a
<span style="color:#a6e22e">fromWeightedList</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">LogicT</span> <span style="color:#f92672">...</span>
</code></pre></div><p>I think i&rsquo;m essentially looking for <code>m [a] -&gt; LogicT m a</code>, the opposite of <code>observeAllT</code> - not sure if this is possible.</p>
<p><strong>JW</strong>:
It&rsquo;s possible &ndash; I&rsquo;m thinking something like:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">nondetermistically</span> <span style="color:#f92672">::</span> m [a] <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">LogicT</span> m a
<span style="color:#a6e22e">nondetermistically</span> mx <span style="color:#f92672">=</span> lift mx <span style="color:#f92672">&gt;&gt;=</span> foldr (<span style="color:#f92672">&lt;|&gt;</span>) empty <span style="color:#f92672">.</span> map pure
</code></pre></div><p>Essentially, promote <code>mx</code> to <code>LogicT m [a]</code>, and then <code>foldr (&lt;|&gt;) empty . map pure :: [a] -&gt; LogicT m a</code>.</p>
<p><strong>MN</strong>:
Could you explain how <code>foldr (&lt;|&gt;) empty . map pure</code> works?</p>
<p><strong>JW</strong>:</p>
<p>The <code>map pure</code> part gives a list of all the nondeterminstic branches which have no computational effect:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">map</span> pure <span style="color:#f92672">::</span> [a] <span style="color:#f92672">-&gt;</span> [<span style="color:#66d9ef">LogicT</span> m a]
</code></pre></div><p>Then <code>foldr (&lt;|&gt;) empty</code> is the choice operation.</p>
<p><strong>MN</strong>:
I think the <code>foldr &lt;|&gt; empty</code> makes sense in terms of its type definition, but im a bit boggled by what it accomplishes.</p>
<p><strong>JW</strong>:
<code>LogicT</code> is the monad of backtracking choice it says nondeterministically pick one of the branches. The <code>map pure</code> says that each branch actually has no computation content &ndash; you are just nondeterministically picking a value from the <code>[a]</code>, hence the <code>LogicT m a</code>. You&rsquo;ll then go on to do some real work (which may involve <code>m</code>), with the result of this choice.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">choice</span> <span style="color:#f92672">=</span> foldr (<span style="color:#f92672">&lt;|&gt;</span>) empty
</code></pre></div><p>For example in parser terminology:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">choice</span> [string <span style="color:#e6db74">&#34;abc&#34;</span>, char <span style="color:#e6db74">&#39;a&#39;</span> <span style="color:#f92672">$&gt;</span> <span style="color:#e6db74">&#34;a&#34;</span>]
</code></pre></div><p><strong>MN</strong>:
Right, does this still retain all the original branches i.e. we can extract them by running <code>observeAllT</code> on the result?</p>
<p><strong>JW</strong>:
Yeah</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">observeAllT</span> <span style="color:#f92672">.</span> nondeterministically <span style="color:#f92672">=</span> id
</code></pre></div><p><strong>MN</strong>:
This is kind of magical to me</p>
<p><strong>JW</strong>:
Well think of it in terms of parsers:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">  map fst <span style="color:#f92672">&lt;$&gt;</span> runParserT (nondeterministically readLine) <span style="color:#e6db74">&#34;&#34;</span>
<span style="color:#f92672">=</span> readLine
</code></pre></div><p>Why? Say the user inputs &ldquo;abc&rdquo; &ndash; then <code>nondeterministically</code> forms the parser:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">pure</span> <span style="color:#e6db74">&#39;a&#39;</span> <span style="color:#f92672">&lt;|&gt;</span> pure <span style="color:#e6db74">&#39;b&#39;</span> <span style="color:#f92672">&lt;|&gt;</span> pure <span style="color:#e6db74">&#39;c&#39;</span> <span style="color:#f92672">&lt;|&gt;</span> empty
</code></pre></div><p>Now suppose your parser is of type <code>String -&gt; m [(a, String)]</code>. Then running that parser is going to return:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">return</span> [(<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#34;&#34;</span>), (<span style="color:#e6db74">&#39;b&#39;</span>, <span style="color:#e6db74">&#34;&#34;</span>), (<span style="color:#e6db74">&#39;c&#39;</span>, <span style="color:#e6db74">&#34;&#34;</span>)]
</code></pre></div><p>Then just throw away that state and you get the original line.</p>
<p>A similar combinator is:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">oneOf</span> <span style="color:#f92672">::</span> [<span style="color:#66d9ef">Char</span>] <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Parser</span> <span style="color:#66d9ef">Char</span>
<span style="color:#a6e22e">oneOf</span> cs <span style="color:#f92672">=</span> foldr (<span style="color:#f92672">&lt;|&gt;</span>) empty <span style="color:#f92672">.</span> map char
</code></pre></div><p>In other words, make all the input characters into parsers that recognise those, and then try each of them in turn. If one branch matches, we are good &ndash; except when you use <code>map pure</code>, then all the branches will succeed, and <code>LogicT</code> observes all successful branches.</p>
<p><strong>MN</strong>:
Ahh, so folding <code>&lt;|&gt;</code> doesn&rsquo;t collapse all of the branches into a non-deterministically chosen branch e.g. <code>pure 'b'</code> , but it combines them into the form <code>pure 'a' &lt;|&gt; pure 'b' &lt;|&gt; pure 'c' &lt;|&gt; empty</code> ?</p>
<p><strong>JW</strong>:
Yeah, that&rsquo;s what fold do right. But the chain of <code>&lt;|&gt;</code>s create a &ldquo;single&rdquo; result which is nondeterministically chosen (which really means, it produces all the results and tries one after the other).</p>
<p><strong>MN</strong>:
And that part doesn&rsquo;t actually happen until you choose to extract a result?</p>
<p><strong>JW</strong>:
Erm, well it happens when it happens. The choice doesn&rsquo;t really happen because it took all possible choices &ndash; they are all processed in parallel as far as I&rsquo;m concerned. It&rsquo;s a black box.</p>
<hr>
<p><strong>MN</strong>:
Is it correct to be able to have a function like <code>State s a -&gt; StateT s m a</code>?</p>
<p><strong>JW</strong>:
I mean you <em>could</em>, but you&rsquo;re basically saying that the Stateful part of that computation is completely pure, in which case it&rsquo;s basically:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">promoteState</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">State</span> s a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">StateT</span> s m a
<span style="color:#a6e22e">promoteState</span> mx <span style="color:#f92672">=</span> <span style="color:#66d9ef">StateT</span> (<span style="color:#a6e22e">\</span>s <span style="color:#f92672">-&gt;</span> return (runState mx s))
</code></pre></div><p>and I&rsquo;m not sure that&rsquo;s particularly valuable. I suppose it allows you to avoid the overhead of performing computation in <code>m</code>, but in the CPS form that&rsquo;s not even a concern anyway because the stateful operations don&rsquo;t even touch the underlying monad.</p>
<p>Also, see <code>state</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">promoteState</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">State</span> s a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">StateT</span> s m a
<span style="color:#a6e22e">promoteState</span> <span style="color:#f92672">=</span> state <span style="color:#f92672">.</span> runState
</code></pre></div><p>It&rsquo;s the inverse of <code>runState</code>, (assuming the <code>State s a</code> here is the non-CPS form).</p>
<p><strong>MN</strong>:
This is all stemming from the mess i&rsquo;m in that i&rsquo;ve got something like:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">MaybeT</span> m a 
 which i need to turn into 
<span style="color:#f92672">&gt;</span> m [<span style="color:#66d9ef">Maybe</span> a] 
 which i need to turn into
<span style="color:#f92672">&gt;</span> [<span style="color:#66d9ef">MaybeT</span> m a] 
</code></pre></div><p><strong>JW</strong>:
That transformation isn&rsquo;t possible, you can&rsquo;t go from a generic monadic context and invert it. The opposite direction is easy.</p>
<p><strong>MN</strong>:
My bad, I meant <code>m [MaybeT m a]</code>, so it looks vaguely like:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">let</span> mx&#39; <span style="color:#f92672">::</span> m ([<span style="color:#66d9ef">Maybe</span> a])
    mx&#39; <span style="color:#f92672">=</span> fmap (<span style="color:#66d9ef">:[]</span>) <span style="color:#f92672">$</span> runMaybeT mx
    foo <span style="color:#f92672">::</span> <span style="color:#66d9ef">MaybeT</span> m a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">MaybeT</span> m a
    foo <span style="color:#f92672">=</span> <span style="color:#f92672">...</span>
<span style="color:#66d9ef">in</span>  <span style="color:#66d9ef">do</span> 
       (x <span style="color:#66d9ef">:</span> xs) <span style="color:#f92672">&lt;-</span> mx&#39; <span style="color:#f92672">::</span> m [<span style="color:#66d9ef">MaybeT</span> m a]
       foo x<span style="color:#f92672">?</span>
</code></pre></div><p><strong>JW</strong>:
The function <code>m [Maybe a] -&gt; [MaybeT m a]</code> is not possible in general, not unless you know how to run out <code>m</code>. The following is fine: <code>m [Maybe a] -&gt; m [MaybeT m a]</code>, but you can&rsquo;t just exit <code>m</code> without knowing how.</p>
<hr>
<p><strong>MN</strong>:
Hi! So I&rsquo;ve got this problem which i don&rsquo;t know is worth/possible solving or not.
Currently, the monad bayes library has a number of modules which contain their own form of the <code>Traced</code> data type, commonly sharing the following structure (where <code>Trace</code> is a monad):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">Traced</span> m a <span style="color:#f92672">=</span> <span style="color:#66d9ef">Traced</span> { <span style="color:#f92672">...</span> , 
                           dist <span style="color:#f92672">::</span> m (<span style="color:#66d9ef">Trace</span> a) 
                         }
</code></pre></div><p>and each <code>Traced</code> data type has a corresponding hoist function:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">hoist</span> <span style="color:#f92672">::</span> (forall x<span style="color:#f92672">.</span> m x <span style="color:#f92672">-&gt;</span> m x) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Traced</span> m a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Traced</span> m a
<span style="color:#a6e22e">hoist</span> f (<span style="color:#66d9ef">Traced</span> <span style="color:#f92672">..</span> dist) <span style="color:#f92672">=</span> <span style="color:#66d9ef">Traced</span> <span style="color:#f92672">..</span> (f dist)
</code></pre></div><p>Instead, I&rsquo;d like to be able to use my own transformer version of <code>Trace</code> inside of <code>Traced</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">Traced</span> m a <span style="color:#f92672">=</span> <span style="color:#66d9ef">Traced</span> { <span style="color:#f92672">...</span> ,
                           dist <span style="color:#f92672">::</span> <span style="color:#66d9ef">TraceT</span> m a,
                         }
</code></pre></div><p>However, now I&rsquo;m not sure how to redefine <code>hoist</code> or what type definition it should have. Do you have any thoughts on this?</p>
<p><strong>JW</strong>:
Well the <code>forall x. m x -&gt; m x</code> implies to me that the function never touches or knows about the trace.</p>
<p><strong>MN</strong>:
This is true.</p>
<p><strong>JW</strong>:
So that&rsquo;s ok. I suspect <code>lift :: m a -&gt; TraceT m a</code> will be a part of it, it depends on how <code>TraceT</code> is defined. If it&rsquo;s the non-CPS version it&rsquo;s easy:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">TraceT</span> mx <span style="color:#f92672">=</span> <span style="color:#66d9ef">TraceT</span> (f mx)
</code></pre></div><p>Otherwise you just need to be a little more creative, but the general idea still applies. It doesn&rsquo;t matter that the monad is carrying around tracey data, because the function works forall x.</p>
<p><strong>MN</strong>:
Unfortunately it&rsquo;s the CPS version:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">TraceT</span> m a <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">TraceT</span> { unTraceT <span style="color:#f92672">::</span> forall r<span style="color:#f92672">.</span> ([<span style="color:#66d9ef">Double</span>] <span style="color:#f92672">-&gt;</span> a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Log</span> <span style="color:#66d9ef">Double</span> <span style="color:#f92672">-&gt;</span> m r) <span style="color:#f92672">-&gt;</span> m r}
  <span style="color:#66d9ef">deriving</span> <span style="color:#66d9ef">Functor</span>
</code></pre></div><p><strong>JW</strong>:
Still easy.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">TraceT</span> k <span style="color:#f92672">=</span> <span style="color:#66d9ef">TraceT</span> (<span style="color:#a6e22e">\</span>ds x log <span style="color:#f92672">-&gt;</span> f (k ds x log))
</code></pre></div><p><strong>MN</strong>:
Ahhh, thank you! My previous (wrong) solution was</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">hoist</span> <span style="color:#f92672">::</span> (<span style="color:#66d9ef">Monad</span> m) <span style="color:#f92672">=&gt;</span> (forall x<span style="color:#f92672">.</span> m x <span style="color:#f92672">-&gt;</span> m x) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">TraceT</span> m a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">TraceT</span> m a
<span style="color:#a6e22e">hoist</span> f mx <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">TraceT</span> <span style="color:#f92672">$</span> (<span style="color:#a6e22e">\</span>k <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">do</span> (<span style="color:#66d9ef">Trace</span> mx&#39;) <span style="color:#f92672">&lt;-</span> f <span style="color:#f92672">$</span> (runTraceT mx)
                     mx&#39; k)
</code></pre></div><p>Even though it type-checks, it doesn&rsquo;t work.</p>
<p><strong>JW</strong>:
I&rsquo;m surprised that type checks &ndash; why does <code>mx'</code> take an argument? <code>TraceT</code> is the CPS form, the <code>Trace</code> that comes out of the <code>runTraceT</code> is not.</p>
<p><strong>MN</strong>:
Ooh, so mine is lol</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">runTraceTCPS</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Monad</span> m <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">TraceTCPS</span> m a <span style="color:#f92672">-&gt;</span> m (<span style="color:#66d9ef">TraceCPS</span> a)
</code></pre></div><p><strong>JW</strong>:
Ok, I&rsquo;d make sure your <code>Trace</code> is non-CPS &ndash; <code>Trace</code> is a data structure, the <code>TraceT</code> is the monad.</p>
<p><strong>MN</strong>:
Got you, thanks. Do you never tend to turn non-transformer monads into CPS?</p>
<p><strong>JW</strong>:
Yes, but in this case <code>Trace</code> is a proper data structure. You can have an internal <code>TraceCPS</code> that gets concretised into <code>Trace</code>, but it wouldn&rsquo;t be useful. The CPS behaviour of <code>TraceT</code> does all the work for you, and also <code>TraceCPS = TraceT Identity</code>.</p>
<hr>
<p><strong>MN</strong>:
I&rsquo;ve got the following code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">Coroutine</span> s m r <span style="color:#f92672">=</span> <span style="color:#66d9ef">Coroutine</span> {
   resume <span style="color:#f92672">::</span> m (<span style="color:#66d9ef">Either</span> (s (<span style="color:#66d9ef">Coroutine</span> s m r)) r)
   }

<span style="color:#66d9ef">instance</span> (<span style="color:#66d9ef">Functor</span> s, <span style="color:#66d9ef">Monad</span> m) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">Monad</span> (<span style="color:#66d9ef">Coroutine</span> s m) <span style="color:#66d9ef">where</span>
  t <span style="color:#f92672">&gt;&gt;=</span> f <span style="color:#f92672">=</span> <span style="color:#66d9ef">Coroutine</span> (resume t <span style="color:#f92672">&gt;&gt;=</span> apply f)
    <span style="color:#66d9ef">where</span> <span style="color:#75715e">-- apply :: (a -&gt; Coroutine s m b)</span>
          <span style="color:#75715e">--       -&gt; Either (s (Coroutine s m a)) a</span>
          <span style="color:#75715e">--       -&gt; m (Either (s (Coroutine s m b)) b)</span>
          apply fc (<span style="color:#66d9ef">Right</span> x) <span style="color:#f92672">=</span> resume (fc x)
          apply fc (<span style="color:#66d9ef">Left</span> s)  <span style="color:#f92672">=</span> return (<span style="color:#66d9ef">Left</span> (fmap (<span style="color:#f92672">&gt;&gt;=</span> fc)) s))
</code></pre></div><p>which i&rsquo;ve spent ages trying to define <code>&gt;&gt;=</code> using <code>EitherCPS</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">EitherCPS</span> e a
  <span style="color:#f92672">=</span> <span style="color:#66d9ef">EitherCPS</span> { unEitherCPS <span style="color:#f92672">::</span> forall r<span style="color:#f92672">.</span> (e <span style="color:#f92672">-&gt;</span> r) <span style="color:#f92672">-&gt;</span> (a <span style="color:#f92672">-&gt;</span> r) <span style="color:#f92672">-&gt;</span> r }

<span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">Coroutine</span> s m r <span style="color:#f92672">=</span> <span style="color:#66d9ef">Coroutine</span> {
   resume <span style="color:#f92672">::</span> m (<span style="color:#66d9ef">EitherCPS</span> (s (<span style="color:#66d9ef">Coroutine</span> s m r)) r)
   }

<span style="color:#66d9ef">instance</span> (<span style="color:#66d9ef">Functor</span> s, <span style="color:#66d9ef">Monad</span> m) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">Monad</span> (<span style="color:#66d9ef">Coroutine</span> s m) <span style="color:#66d9ef">where</span>
  t <span style="color:#f92672">&gt;&gt;=</span> f <span style="color:#f92672">=</span> <span style="color:#66d9ef">Coroutine</span> (resume t <span style="color:#f92672">&gt;&gt;=</span> apply f)
    <span style="color:#66d9ef">where</span> apply fc (<span style="color:#66d9ef">EitherCPS</span> k) <span style="color:#f92672">=</span> <span style="color:#f92672">???</span>
</code></pre></div><p>but i don&rsquo;t know if this is possible, could i check with you?</p>
<p><strong>JW</strong>:
Of course it is &ndash; think about the relation between the continuations and the pattern cases.</p>
<p><strong>MN</strong>:
I&rsquo;m having a massive problem handling the <code>resume</code> and <code>return</code>, it seems like i&rsquo;m getting close, but then i can&rsquo;t get the types to match.</p>
<p>I&rsquo;ll show you an attempt:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">apply</span> fc (<span style="color:#66d9ef">EitherCPS</span> k) <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">EitherCPS</span> <span style="color:#f92672">$</span> <span style="color:#a6e22e">\</span>l r <span style="color:#f92672">-&gt;</span> k (l <span style="color:#f92672">.</span> (<span style="color:#a6e22e">\</span>s <span style="color:#f92672">-&gt;</span> (fmap (<span style="color:#f92672">&gt;&gt;=</span> fc) s)))
                          (r <span style="color:#f92672">.</span> (<span style="color:#a6e22e">\</span>x <span style="color:#f92672">-&gt;</span> (fc x)))
</code></pre></div><p>but then i&rsquo;m not sure how to fit in <code>resume</code> and <code>return</code> from the original definition.</p>
<p><strong>JW</strong>:
Your issue is you haven&rsquo;t cps&rsquo;d <code>Coroutine</code> itself I believe, and when you do that you might as well inline <code>EitherCPS</code> straight into it.</p>
<p><strong>MN</strong>:
Ooh okay, i had no idea that was necessary, i&rsquo;ll try giving that a go right now, thanks!
I&rsquo;m guessing it looks like:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">Coroutine</span> s m a <span style="color:#f92672">=</span> <span style="color:#66d9ef">Coroutine</span> { 
  unCoroutine <span style="color:#f92672">::</span> forall r<span style="color:#f92672">.</span> 
                 (m (<span style="color:#66d9ef">EitherCPS</span> (s (<span style="color:#66d9ef">Coroutine</span> s m a)) a) <span style="color:#f92672">-&gt;</span> r)
              <span style="color:#f92672">-&gt;</span> r
}
</code></pre></div><p><strong>JW</strong>:
I actually suspect it&rsquo;s <code>(EitherCPS s ... -&gt; m r) -&gt; m r</code></p>
<p><strong>MN</strong>:
Hm, this looks different from the normal translation i&rsquo;m used to</p>
<p><strong>JW</strong>:
Nope! When I CPS:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">IdentityT</span> m a <span style="color:#f92672">=</span> <span style="color:#66d9ef">Identity</span> (m a)
</code></pre></div><p>It becomes:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">IdentityT</span> m a <span style="color:#f92672">=</span> <span style="color:#66d9ef">Identity</span> (forall r<span style="color:#f92672">.</span> (a <span style="color:#f92672">-&gt;</span> m r) <span style="color:#f92672">-&gt;</span> m r)
</code></pre></div><p>which is, hey presto, <code>Cod</code>.</p>
<p><strong>MN</strong>:
Ohh right! i forgot it was even a monad transformer.</p>
<hr>
<p><strong>MN</strong>:
Hiya! I&rsquo;m converting a lot of the <code>Coroutine</code> library to CPS, where:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#75715e">-- Original Coroutine:</span>
<span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">Coroutine</span> s m a <span style="color:#f92672">=</span> <span style="color:#66d9ef">Coroutine</span> { resume <span style="color:#f92672">::</span> m (<span style="color:#66d9ef">Either</span> (s (<span style="color:#66d9ef">Coroutine</span> s m a)) a) }
<span style="color:#75715e">-- CPS&#39;d Coroutine:</span>
<span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">Coroutine&#39;</span> s m a <span style="color:#f92672">=</span> <span style="color:#66d9ef">Coroutine&#39;</span> { resume&#39; <span style="color:#f92672">::</span> forall r<span style="color:#f92672">.</span> (s (<span style="color:#66d9ef">Coroutine&#39;</span> s m a) <span style="color:#f92672">-&gt;</span> m r) <span style="color:#f92672">-&gt;</span> (a <span style="color:#f92672">-&gt;</span> m r) <span style="color:#f92672">-&gt;</span> m r }
<span style="color:#a6e22e">runCoroutine&#39;</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Monad</span> m <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">Coroutine&#39;</span> s m a <span style="color:#f92672">-&gt;</span> m (<span style="color:#66d9ef">Either</span> (s (<span style="color:#66d9ef">Coroutine&#39;</span> s m a)) a)
</code></pre></div><p>But I&rsquo;m finding that in a lot of functions i&rsquo;m converting which involve monadic computation with <code>m</code>, such as:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">f</span> <span style="color:#f92672">::</span> m (<span style="color:#66d9ef">Either</span> (s (<span style="color:#66d9ef">Coroutine</span> s m a)) a) 
  <span style="color:#f92672">-&gt;</span> m (<span style="color:#66d9ef">Either</span> (s (<span style="color:#66d9ef">Coroutine</span> s m b)) b)
<span style="color:#a6e22e">foo</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Coroutine</span> s m a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Coroutine</span> s m b 
<span style="color:#a6e22e">foo</span> cort <span style="color:#f92672">=</span> <span style="color:#66d9ef">Coroutine</span> { f ( resume cort ) }
</code></pre></div><p>The CPS version i write always tends to involve me calling <code>runCoroutine'</code> and having to pattern match on <code>Either</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">foo</span> cort <span style="color:#f92672">=</span> <span style="color:#66d9ef">Coroutine&#39;</span> (<span style="color:#a6e22e">\</span>l r <span style="color:#f92672">-&gt;</span> x <span style="color:#f92672">&lt;-</span> f (runCoroutine&#39; cort)
                               <span style="color:#66d9ef">case</span> x <span style="color:#66d9ef">of</span>
                                  <span style="color:#66d9ef">Right</span> rv <span style="color:#f92672">-&gt;</span> r rv
                                  <span style="color:#66d9ef">Left</span>  lv <span style="color:#f92672">-&gt;</span> l lv )
</code></pre></div><p>Am i doing it wrong?</p>
<p><strong>JW</strong>:
What is <code>foo</code>?</p>
<p><strong>MN</strong>:
Some function that just applies <code>f</code> to the <code>m (Either (s (Coroutine s m a)) a)</code> inside of <code>Coroutine</code>.</p>
<p><strong>JW</strong>:
Right but it must have a &ldquo;normal&rdquo; name.</p>
<p><strong>MN</strong>:
Shall i give you a more concrete example?</p>
<p><strong>JW</strong>:
Yes.</p>
<p><strong>MN</strong>:
Original non-CPS&rsquo;d version of <code>liftBinder</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">Coroutine</span> s m a <span style="color:#f92672">=</span> <span style="color:#66d9ef">Coroutine</span> { resume <span style="color:#f92672">::</span> m (<span style="color:#66d9ef">Either</span> (s (<span style="color:#66d9ef">Coroutine</span> s m a)) a) }

<span style="color:#66d9ef">type</span> <span style="color:#66d9ef">PairBinder</span> m <span style="color:#f92672">=</span> forall x y r<span style="color:#f92672">.</span> (x <span style="color:#f92672">-&gt;</span> y <span style="color:#f92672">-&gt;</span> m r) <span style="color:#f92672">-&gt;</span> m x <span style="color:#f92672">-&gt;</span> m y <span style="color:#f92672">-&gt;</span> m r

<span style="color:#a6e22e">liftBinder</span> <span style="color:#f92672">::</span> forall s m<span style="color:#f92672">.</span> (<span style="color:#66d9ef">Functor</span> s, <span style="color:#66d9ef">Monad</span> m) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">PairBinder</span> m <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">PairBinder</span> (<span style="color:#66d9ef">Coroutine</span> s m)
<span style="color:#a6e22e">liftBinder</span> binder f t1 t2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">Coroutine</span> (binder combine (resume t1) (resume t2)) 
  <span style="color:#66d9ef">where</span>
   combine (<span style="color:#66d9ef">Right</span> x) (<span style="color:#66d9ef">Right</span> y) <span style="color:#f92672">=</span> resume (f x y)
   combine (<span style="color:#66d9ef">Left</span> s) (<span style="color:#66d9ef">Right</span> y)  <span style="color:#f92672">=</span> return <span style="color:#f92672">$</span> <span style="color:#66d9ef">Left</span> (fmap (flip f y <span style="color:#f92672">=&lt;&lt;</span>) s)
   combine (<span style="color:#66d9ef">Right</span> x) (<span style="color:#66d9ef">Left</span> s)  <span style="color:#f92672">=</span> return <span style="color:#f92672">$</span> <span style="color:#66d9ef">Left</span> (fmap (f x <span style="color:#f92672">=&lt;&lt;</span>) s)
   combine (<span style="color:#66d9ef">Left</span> s1) (<span style="color:#66d9ef">Left</span> s2) <span style="color:#f92672">=</span> return <span style="color:#f92672">$</span> <span style="color:#66d9ef">Left</span> (fmap (liftBinder binder f <span style="color:#f92672">$</span> suspend s1) s2)
</code></pre></div><p>CPS&rsquo;d version of <code>liftBinder</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">Coroutine&#39;</span> s m a <span style="color:#f92672">=</span> <span style="color:#66d9ef">Coroutine&#39;</span> { resume&#39; <span style="color:#f92672">::</span> forall r<span style="color:#f92672">.</span> (s (<span style="color:#66d9ef">Coroutine&#39;</span> s m a) <span style="color:#f92672">-&gt;</span> m r) <span style="color:#f92672">-&gt;</span> (a <span style="color:#f92672">-&gt;</span> m r) <span style="color:#f92672">-&gt;</span> m r }

<span style="color:#a6e22e">runCoroutine&#39;</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Monad</span> m <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">Coroutine&#39;</span> s m a <span style="color:#f92672">-&gt;</span> m (<span style="color:#66d9ef">Either</span> (s (<span style="color:#66d9ef">Coroutine&#39;</span> s m a)) a)

<span style="color:#66d9ef">type</span> <span style="color:#66d9ef">PairBinder</span> m <span style="color:#f92672">=</span> forall x y r<span style="color:#f92672">.</span> (x <span style="color:#f92672">-&gt;</span> y <span style="color:#f92672">-&gt;</span> m r) <span style="color:#f92672">-&gt;</span> m x <span style="color:#f92672">-&gt;</span> m y <span style="color:#f92672">-&gt;</span> m r

<span style="color:#a6e22e">liftBinder</span> <span style="color:#f92672">::</span> forall s m<span style="color:#f92672">.</span> (<span style="color:#66d9ef">Functor</span> s, <span style="color:#66d9ef">Monad</span> m) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">PairBinder</span> m <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">PairBinder</span> (<span style="color:#66d9ef">Coroutine&#39;</span> s m)
<span style="color:#a6e22e">liftBinder</span> binder f t1 t2 <span style="color:#f92672">=</span>
   <span style="color:#66d9ef">Coroutine</span> (<span style="color:#a6e22e">\</span>l r <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">do</span> x <span style="color:#f92672">&lt;-</span> binder combine (runCoroutine&#39; t1) (runCoroutine&#39; t2)
                         <span style="color:#66d9ef">case</span> x <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">Right</span> rv <span style="color:#f92672">-&gt;</span> r rv
                                   <span style="color:#66d9ef">Left</span>  lv <span style="color:#f92672">-&gt;</span> l lv)
   <span style="color:#66d9ef">where</span>
    combine (<span style="color:#66d9ef">Right</span> x) (<span style="color:#66d9ef">Right</span> y) <span style="color:#f92672">=</span> runCoroutine&#39; (f x y)
    combine (<span style="color:#66d9ef">Left</span> s) (<span style="color:#66d9ef">Right</span> y)  <span style="color:#f92672">=</span> return <span style="color:#f92672">$</span> <span style="color:#66d9ef">Left</span> (fmap (flip f y <span style="color:#f92672">=&lt;&lt;</span>) s)
    combine (<span style="color:#66d9ef">Right</span> x) (<span style="color:#66d9ef">Left</span> s)  <span style="color:#f92672">=</span> return <span style="color:#f92672">$</span> <span style="color:#66d9ef">Left</span> (fmap (f x <span style="color:#f92672">=&lt;&lt;</span>) s)
    combine (<span style="color:#66d9ef">Left</span> s1) (<span style="color:#66d9ef">Left</span> s2) <span style="color:#f92672">=</span> return <span style="color:#f92672">$</span> <span style="color:#66d9ef">Left</span> (fmap (liftBinder binder f <span style="color:#f92672">$</span> suspend s1) s2)
</code></pre></div><p><strong>JW</strong>:
I think I see how to do this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">resume&#39;</span> t1 (<span style="color:#a6e22e">\</span>s1 <span style="color:#f92672">-&gt;</span> resume&#39; t2 (<span style="color:#a6e22e">\</span>s2 <span style="color:#f92672">-&gt;</span> return (<span style="color:#66d9ef">Left</span> (fmap (liftBinder <span style="color:#f92672">...</span>)) (<span style="color:#a6e22e">\</span>y <span style="color:#f92672">-&gt;</span> return (<span style="color:#66d9ef">Left</span> (fmap (flip<span style="color:#f92672">...</span>)))))
           (<span style="color:#a6e22e">\</span>x <span style="color:#f92672">-&gt;</span> resume&#39; t2 (<span style="color:#a6e22e">\</span>s <span style="color:#f92672">-&gt;</span> return (<span style="color:#66d9ef">Left</span> (fmap (f x <span style="color:#f92672">=&lt;&lt;</span> <span style="color:#f92672">...</span>))) (<span style="color:#a6e22e">\</span>y <span style="color:#f92672">-&gt;</span> runCoroutine&#39; (f x y)))
</code></pre></div><p>Think about the four cases in terms of how each continuation can reach it &ndash; whenever you match on <code>Either</code>, you just use the continuations instead. P.S. there is no way that expression is well-bracketed, but you should get the picture.</p>
<p><strong>MN</strong>:
Oh wow, so, we don&rsquo;t even have to use <code>binder</code>?</p>
<p><strong>JW</strong>:
You do. I just didn&rsquo;t put it in there, it either stays on the outside, or it goes on the inside of each one. I&rsquo;m not sure which, I just translated the <code>combine</code> application. It&rsquo;s possible <code>binder</code> needs a different type.</p>
<p><strong>MN</strong>:
Oh right! So that&rsquo;s <code>combine t1 t2</code>.</p>
<p><strong>JW</strong>:
Yeah</p>
<p><strong>MN</strong>:
That&rsquo;s so awesome, i was thinking about that approach but i wasn&rsquo;t sure how the cases translated to branching of continuations, thanks loads! I&rsquo;ll have a try at fitting the rest in.</p>
<p><strong>JW</strong>:
I would probably not try and translate what I did, but use the principal. Really, you should implement a parser combinator library, it helps with this sort of thing. It&rsquo;s basically 100% juggling these dual continuation structures (or in Parsecs case quad-continuation).</p>
<hr>
<p>Minh  7:54 PM
i&rsquo;ve forgotten how to use RankNTypes, how does one do something like :
evalDist :: Dist d =&gt; [Double] -&gt; d
evalDist (μ: σ: _) = normalDist μ σ
where normalDist returns a concrete type NormalDist which is an instance of the class Dist?</p>
<p>Jamie Willis  8:10 PM
erm
8:10
not sure what you mean</p>
<p>Minh  8:10 PM
hm, so, i want to return a value where all i know about it is that its an instance of a certain class
8:11
but in the actual function definition, i want to be able to return different concrete types, where i know they have instances of that class
8:12
but i&rsquo;m getting errors like
Couldn&rsquo;t match expected type &rsquo;d'
with actual type &lsquo;NormalDistribution&rsquo;
&rsquo;d' is a rigid type variable bound by &hellip;</p>
<p>Jamie Willis  8:23 PM
oh I think you want existentials
8:23
I always struggle with this stuff
8:23
but you basically want to capture the instance in the data constructor
8:24
image.png
image.png</p>
<p>8:24
there is an example
New
8:24
the SAME constructor has a positionOps instance
8:24
the instance must be present when the SAME value is made
:heart:
1</p>
<p>8:24
and whenever we pattern match on SAME the instance is available</p>
<p>Minh  8:31 PM
is it possible to place that constraint on the a of Defunc?</p>
<p>Jamie Willis  8:32 PM
In a constructor sure
8:32
not on the main a at the top I don&rsquo;t think no</p>
<hr>
<p>Minh  4:10 PM
is it possible to do this somehow:
instance Show s =&gt; Pretty s where
pretty = show
For default types which don&rsquo;t have a specific Pretty instance, but do have a Show instance</p>
<p>Jamie Willis  10:28 AM
I think you can mark it as incoherent
10:28
which means it&rsquo;s only chosen if there isn&rsquo;t another alternative</p>
<hr>
<p>Minh  1:43 PM
i&rsquo;m wondering how when works in the following example for callCC:
&ndash; Returns a string depending on the length of the name parameter.
&ndash; If the provided string is empty, returns an error.
&ndash; Otherwise, returns a welcome message.
whatsYourName :: String -&gt; String
whatsYourName name =
(<code>runCont</code> id) $ do                      &ndash; 1
response &lt;- callCC $ \exit -&gt; do       &ndash; 2
validateName name exit               &ndash; 3
return $ &ldquo;Welcome, &quot; ++ name ++ &ldquo;!&rdquo;  &ndash; 4
return response                        &ndash; 5
validateName name exit = do
when (null name) (exit &ldquo;You forgot to tell me your name!&quot;)
i&rsquo;m confused about the possible return values of when, and how validateName name exit can be ignored as a return value if null name is false in validateName</p>
<p>Jamie Willis  1:45 PM
think of exit as an early return statement
1:45
and when as an if without an else</p>
<p>Minh  1:45 PM
wouldn&rsquo;t exit just be id in this case</p>
<p>Jamie Willis  1:45 PM
I feel like you got confused about this before</p>
<p>Minh  1:45 PM
yeah im reading over our old conversation</p>
<p>Jamie Willis  1:46 PM
exit is return
1:46
from line 5 (edited)
1:46
I would just inline the definitions and see how they fall together
1:47
exit is essentially goto line 5
1:47
except it has a value, which becomes response</p>
<p>Minh  1:47 PM
right, i get how it can exit early, similarly to when you have the following:
do return 5
return 6
this will just return 5</p>
<p>Jamie Willis  1:47 PM
if it&rsquo;s not called then whatever was the last expression in the callCC &ldquo;body&rdquo; is returned
1:47
that will return 6</p>
<p>Minh  1:47 PM
what</p>
<p>Jamie Willis  1:47 PM
return isn&rsquo;t like an imperative return
1:48
but callCC&rsquo;s function is
1:48
it&rsquo;s a goto
1:48
you goto whatever follows the callCC
1:48
this is why I don&rsquo;t like return
1:48
I like pure for this very reason
1:49
it&rsquo;s clear that
do pure 5
pure 6
1:49
returns 6
1:49
and it&rsquo;s identical to using return
1:49
the callCC has, in your example
1:50
created a continuation called exit with the shape \response -&gt; return response (edited)
1:50
if you call exit at any time, your continuation is ignored
1:50
and you do exit instead
New
1:50
again, just inline it and see
1:51
computations in Cont don&rsquo;t return, they just go somewhere else</p>
<p>Minh  1:51 PM
okay thanks, will do so</p>
<p>Jamie Willis  1:51 PM
do notation just makes &ldquo;go somewhere else&rdquo; look like sequentiality</p>
<p>Minh  2:27 PM
right, so inlining it looks like
whatsYourName' :: String -&gt; Cont r String
whatsYourName' name = do
response &lt;- cont (\k -&gt; runCont (do validateName name (\x -&gt; cont (_ -&gt; k x))
return $ &ldquo;welcome, &quot; ++ name
) k
)
return response
2:27
so im guessing that the exit is always (\x -&gt; cont (_ -&gt; k x))</p>
<p>Jamie Willis  2:27 PM
it is here
2:27
not in general
2:28
oh wait
2:28
no it is
2:28
I thought you&rsquo;d inlined k</p>
<p>Minh  2:29 PM
i see, so the line return $ &ldquo;welcome, _&rdquo; ++ name  acts as the continuation _ which is ignored</p>
<p>Jamie Willis  2:29 PM
yup</p>
<p>Minh  2:30 PM
but otherwise, when will just return pure ()
New</p>
<p>Jamie Willis  2:31 PM
sure</p>
<p>Minh  4:36 PM
this is weird, in the following:
validateName name exit = do
when (null name) (exit &ldquo;you forgot to tell me your name&rdquo;)
if when has type Bool -&gt; f () -&gt; f (),  how does exit let us produce a type f () (edited)
4:38
assuming that exit is always (\x -&gt; cont (_ -&gt; k x))
New</p>
<p>Jamie Willis  4:39 PM
look at the type of callCC
4:39
exit doesn&rsquo;t return
4:39
it never produces a valid to the context that calls it
4:40
so it can return any type you want, call it b
4:40
in when&rsquo;s case, that&rsquo;s ()</p>
<hr>
<p>Minh  11:31 AM
I&rsquo;ve got a problem that i&rsquo;m not sure how to solve elegantly, i wonder if you&rsquo;ve ever tried anything like this? I have a small DSL, and i want to perform a source-to-source language translation that allows me to attach a unique identifier to each current location in the program execution. But during this translation, the data type for the language must remain the same. This is like assigning a stack trace to each expression.</p>
<p>New</p>
<p>Jamie Willis  11:32 AM
HasCallStack
11:32
Or StableName
11:32
I&rsquo;ve used StableNames
:+1:
1</p>
<p>Minh  11:54 AM
did you find that you had to make any modifications to your language to incorporate StableNames, e.g. add an extra parameter to a constructor to store an StableName identifier ?</p>
<p>Jamie Willis  11:55 AM
have a read of the staged selective parser combinators paper (edited)
:+1:
1</p>
<p>Minh  12:02 PM
ooh i see, so the names are held implicitly somewhere</p>
<p>Jamie Willis  12:53 PM
sure
12:53
or you can regenerate them</p>
<p>12:53
they give the same name every time</p>
<p>Minh  12:54 PM
im not sure if im understanding correctly, but do you use a hashmap to be able to resume your program from different points of execution? (edited)</p>
<p>Jamie Willis  12:55 PM
when?</p>
<p>Minh  12:55 PM
image.png
image.png</p>
<p>Jamie Willis  12:55 PM
I don&rsquo;t &ldquo;resume&rdquo; anything there
12:55
I&rsquo;m tracking them
12:56
I keep the Map from StableNames to Ints
12:56
later
12:56
I reference them by their Ints</p>
<p>Minh  12:56 PM
right, is it possible to perform that functionality though
12:56
through what you&rsquo;ve done</p>
<p>Jamie Willis  12:56 PM
then I have a dependent Map from Int to Functions
12:57
and later when I see Call n I can run the function at mus DMap.! n
12:57
that&rsquo;s not in the paper though</p>
<p>Minh  12:57 PM
ooh i see, interesting
12:57
is there is a reason why you didn&rsquo;t use a map directly from stable names to their function</p>
<p>Jamie Willis  12:58 PM
a) Stable names require IO around
12:58
I wanted to get rid of that quickly
12:58
b) the entire tree is transformed multiple times, the StableNames wouldn&rsquo;t be right anymore by the end
:+1:
1</p>
<p>New
12:58
they are right at the beginning though
:+1:
1</p>
<p>Minh  12:38 PM
Hi, im wondering about how to correctly evaluate the following example:
g = let x = 5
f   = \y -&gt; y + x
x   = 10
h f = \a -&gt; f a
in  h f 15
At line 2, i&rsquo;m assuming we&rsquo;ve previously evaluated f to a closure with an environment  {x → 5}  .
However, the environment when evaluating h f 15 would be {x → 10} .
When merging the two environments at h f 15, is it correct to say that the current environment takes precedence over the closure&rsquo;s environment?</p>
<p>Jamie Willis  12:39 PM
I think it&rsquo;s {x → 5}
12:39
but I would just test it</p>
<p>Minh  12:39 PM
it isn&rsquo;t haskell im doing it in, its just my own language
12:39
so i&rsquo;m wondering about whether this is a design choice
12:39
or if there&rsquo;s a single correct way</p>
<p>Jamie Willis  12:40 PM
I would check other languages
12:40
I think it boils down to by-name evaluation or not
:+1:
1</p>
<p>12:40
hard to tell
12:40
also, don&rsquo;t forget: you don&rsquo;t have to work weekends as a PhD student :slightly_smiling_face:</p>
<hr>
<p>Minh  2:58 PM
is there a way to use the Cont monad to both exit early with a value (using callCC) as well as return the rest of the execution that wasn&rsquo;t carried out</p>
<p>New</p>
<p>Jamie Willis  2:58 PM
two callCCs?
2:59
restOfWork &lt;- callCC (\exit -&gt;
&hellip;
leave exit)
where
leave = callCC (\rest -&gt; exit rest)
3:00
that implies the type of restOfWork is itself a continuation
3:00
it&rsquo;s the sort of thing you can do when you want to implement co-operative multi-tasking</p>
<hr>
<p>Minh  10:43 AM
I&rsquo;ve been trying to use the Cont monad with callCC to return the rest of computation to be resumed later, similar to how Coroutine (i.e. the free monad) works with yield or await . (This is just me trying to sanity check whether this is possible). I&rsquo;ve also tried your approach of using two callCCs , but all i&rsquo;m able to do so far is exit the computation early. Have i misunderstood what&rsquo;s possible using the Cont monad? (edited)</p>
<p>Jamie Willis  10:43 AM
you will exit the computation early, if you don&rsquo;t put the continutation somewhere
10:44
you need to store then if you want the yield behaviour</p>
<p>Minh  10:45 AM
could you elaborate on how one &ldquo;puts the continuation somewhere&rdquo;?</p>
<p>Jamie Willis  10:45 AM
in a list?
10:45
i.e.
10:45
StateT [Thread] (Cont &hellip;)
10:46
yield does a callCC, puts the continuation in the state, and then calls another continuation from that state</p>
<p>Minh  10:47 AM
ah right, so i&rsquo;m only able to store/capture the computation that is inside callCC?</p>
<p>Jamie Willis  10:47 AM
yup
10:48
callCC (\k -&gt; storeAndRecall k)
(edited)
10:48
something like that</p>
<p>Minh  10:58 AM
right, i&rsquo;m not sure i understand how to use that. If i had an interpreter eval :: Expr -&gt; Val that needed to pause at certain places, i would do callCC (\k -&gt; eval k expr) somehow?
New</p>
<p>Jamie Willis  11:09 AM
it would be something like
11:09
you make the yield operation
11:10
and first you load all of the coroutines into the list
11:10
(if you are using await to spawn off, then that&rsquo;s how they make it into the list)
11:10
and then you schedule one of them
11:10
it starts running, when it yields it takes the remainder of the continuation, pops it into the list, and then schedules another continuation in the list
11:11
cast your mind all the way back to the cooperative multithreading in the OS coursework in second year
11:11
you&rsquo;re basically context-switching in and out continuations</p>
<p>Minh  11:11 AM
thanks a lot, i&rsquo;ll give this a go</p>
<hr>
<p>I&rsquo;m experimenting with GADTs to create an embedded DSL. It appears that the following definition of lambda functions can only support functions of one argument, so we have to nest lambdas to achieve multi-parameter functions.
data Expr t where
Lam      :: (Expr a -&gt; Expr b) -&gt; Expr (a -&gt; b)
exampleFn :: Expr (Int -&gt; Int -&gt; Int)
exampleFn = Lam (\a -&gt; Lam (\b -&gt; a))
Is there a way to achieve this without having to nest lambdas?</p>
<p>Jamie Willis  1:35 PM
Heterogenous lists
New
1:36
Lam :: (ExprList as -&gt; Expr b) -&gt; Expr (HigherArity as b)
1:37
type family HigherArity (as :: [*]) (b :: *) :: * where
HigherArity &lsquo;[] b = b
HigherArity (a &lsquo;: as) b = a -&gt; HigherArity as b</p>
<p>Minh  1:37 PM
wow this looks freaky</p>
<p>Jamie Willis  1:38 PM
data ExprList (as :: [*]) where
ExprNil :: ExprList &lsquo;[]
ExprCons :: Expr a -&gt; ExprList as -&gt; ExprList (a &lsquo;: as)
1:38
{-# LANGUAGE DataKinds #-}</p>
<p>Minh  1:38 PM
thanks i&rsquo;ll try this out! :slightly_smiling_face:</p>
<div class="edit-meta">
Last updated on 13 Nov 2020


<br>
Published on 13 Nov 2020
<br></div><nav class="pagination"><a class="nav nav-prev" href="https://probabilistic-effects.github.io/research/literature-review/" title="Literature Review"><i class="fas fa-arrow-left" aria-hidden="true"></i> Prev - Literature Review</a>
<a class="nav nav-next" href="https://probabilistic-effects.github.io/research/optimising-core/" title="Optimising Core">Next - Optimising Core <i class="fas fa-arrow-right" aria-hidden="true"></i></a>
</nav><footer><p class="powered">Powered by <a href="https://gohugo.io">Hugo</a>. Theme by <a href="https://themes.gohugo.io/hugo-theme-techdoc/">TechDoc</a>. Designed by <a href="https://github.com/thingsym/hugo-theme-techdoc">Thingsym</a>.</p>
</footer>
</main>
<div class="sidebar">

<nav class="open-menu">
<ul>
<li class=""><a href="https://probabilistic-effects.github.io/">Home</a></li>

<li class=""><a href="https://probabilistic-effects.github.io/activity/">Activity</a>
  
<ul class="sub-menu">
<li class=""><a href="https://probabilistic-effects.github.io/activity/cpsing-monad-bayes/">CPSing Monad Bayes</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/activity/inlining-monad-bayes/">Inlining Monad Bayes</a></li>
</ul>
  
</li>

<li class=""><a href="https://probabilistic-effects.github.io/papers/">Papers</a>
  
<ul class="sub-menu">
<li class=""><a href="https://probabilistic-effects.github.io/papers/asymptotic-improvement/">Asymptotic Improvement of Computations over Free Monads</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/papers/anglican/">Design and Implementation of Probabilistic Programming Language Anglican</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/papers/extensible-effects/">Extensible Effects</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/papers/faster-coroutine-pipelines/">Faster Coroutine Pipelines</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/papers/freer-monads/">Freer Monads, More Extensible Effects</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/papers/fusion-for-free/">Fusion for Free</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/papers/hakaru/">Hakaru - Probabilistic Inference by Program Transformation</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/papers/hansei/">Hansei - Embedded Domain-Specific Languages for Probabilistic Programming (Oleg)</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/papers/probabilistic-programming/">Introduction To Probabilistic Programming</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/papers/lightweight-implementations-prob-languages/">Lightweight Implementations of Probabilistic Programming Languages</a></li>
</ul>
  
</li>

<li class="parent"><a href="https://probabilistic-effects.github.io/research/">Research</a>
  
<ul class="sub-menu">
<li class=""><a href="https://probabilistic-effects.github.io/research/research-journal/">Research Journal</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/research/approaches-for-monad-bayes/">Potential Approaches to Improving Monad Bayes</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/research/probabilistic-design/">Probabilistic Language Design</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/research/effects-for-less/">Effects for Less</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/research/literature-review/">Literature Review</a></li>
<li class="active"><a href="https://probabilistic-effects.github.io/research/parsley-case-study/">Case Study: Optimising Parsley</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/research/optimising-core/">Optimising Core</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/research/alex/"></a></li>
</ul>
  
</li>

<li class=""><a href="https://probabilistic-effects.github.io/monad-bayes/">Monad Bayes</a>
  
<ul class="sub-menu">
<li class=""><a href="https://probabilistic-effects.github.io/monad-bayes/inference-transformers/">Inference Transformers</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/monad-bayes/pmmh-hmm/">Implementing HMM Simulation and Inference (using PMMH)</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/monad-bayes/documentation/">Documentation</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/monad-bayes/conditioning-scoring/">How Conditioning and Scoring Works</a></li>
</ul>
  
</li>

<li class=""><a href="https://probabilistic-effects.github.io/tooling/">Tooling</a>
  
<ul class="sub-menu">
<li class=""><a href="https://probabilistic-effects.github.io/tooling/cabal/">Cabal Projects</a></li>
</ul>
  
</li>

<li class=""><a href="https://probabilistic-effects.github.io/benchmarking/">Benchmarking</a>
  
<ul class="sub-menu">
<li class=""><a href="https://probabilistic-effects.github.io/benchmarking/benchmark-log/">Benchmark Log</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/benchmarking/benchmarking-profiling/">How to Benchmark and Profile</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/benchmarking/monad-bayes-components/">Relevant Components of Monad Bayes for Profiling</a></li>
</ul>
  
</li>

<li class=""><a href="https://probabilistic-effects.github.io/background/">Background</a>
  
<ul class="sub-menu">
<li class=""><a href="https://probabilistic-effects.github.io/background/embedding/">Embedding DSLs</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/background/staging/">Staging</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/background/smc-pmmh/">SMC and PMMH</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/background/handrolling/">Handrolling Monad Transformer Stacks</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/background/mtl/">MTL</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/background/mcmc-mh/">MCMC and MH</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/background/markov-chain/">Markov Chains</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/background/hidden-markov-model/">Hidden Markov Model</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/background/delimited-continuations/">Delimited Continuations</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/background/haskell-core/">Haskell Core</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/background/inlining/">Inlining</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/background/specialisation/">Specialisation</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/background/bayesian/">Bayesian</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/background/concurrency/">Concurrency</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/background/continuations/">Continuations</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/background/coroutines/">Coroutines</a></li>
</ul>
  
</li>
</ul>
</nav>



<div class="sidebar-footer"></div>
</div>

</div><a href="#" id="backtothetop-fixed" class="backtothetop"
 data-backtothetop-duration="600"
 data-backtothetop-easing="easeOutQuart"
 data-backtothetop-fixed-fadeIn="1000"
 data-backtothetop-fixed-fadeOut="1000"
 data-backtothetop-fixed-bottom="10"
 data-backtothetop-fixed-right="20">
<span class="fa-layers fa-fw">
<i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i>
</span></a>
</div>
</body>
</html>

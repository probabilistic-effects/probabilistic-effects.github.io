<!DOCTYPE html>
<html lang="en-us">
<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>Fusion for Free - Probabilistic Effects.  λθ</title>
<meta name="generator" content="Hugo 0.78.2" />
<link href="https://probabilistic-effects.github.io//index.xml" rel="alternate" type="application/rss+xml">
<link rel="canonical" href="https://probabilistic-effects.github.io/papers/fusion-for-free/">
<link rel="stylesheet" href="https://probabilistic-effects.github.io/css/theme.min.css">
<script src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script>
<link rel="stylesheet" href="https://probabilistic-effects.github.io/css/chroma.min.css">
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script>
<script src="https://probabilistic-effects.github.io/js/bundle.js"></script><style>
:root {}
</style>
<meta property="og:title" content="Fusion for Free" />
<meta property="og:description" content="Free monads are at the heart of algebraic effect handlers, a functional approach for modelling side effects which allows the separation of the syntax and semantics of effectful operations, whilst enabling us to provide multiple different semantics for the same syntax.
The syntax of primitive side-effect operations is captured in a signature functor. The free monad over this functor assembles the syntax for the individual operations into an abstract syntax tree for an effectful program." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://probabilistic-effects.github.io/papers/fusion-for-free/" />
<meta property="article:published_time" content="2020-11-13T14:05:41+00:00" />
<meta property="article:modified_time" content="2020-11-13T14:05:41+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Fusion for Free"/>
<meta name="twitter:description" content="Free monads are at the heart of algebraic effect handlers, a functional approach for modelling side effects which allows the separation of the syntax and semantics of effectful operations, whilst enabling us to provide multiple different semantics for the same syntax.
The syntax of primitive side-effect operations is captured in a signature functor. The free monad over this functor assembles the syntax for the individual operations into an abstract syntax tree for an effectful program."/>
<meta itemprop="name" content="Fusion for Free">
<meta itemprop="description" content="Free monads are at the heart of algebraic effect handlers, a functional approach for modelling side effects which allows the separation of the syntax and semantics of effectful operations, whilst enabling us to provide multiple different semantics for the same syntax.
The syntax of primitive side-effect operations is captured in a signature functor. The free monad over this functor assembles the syntax for the individual operations into an abstract syntax tree for an effectful program.">
<meta itemprop="datePublished" content="2020-11-13T14:05:41+00:00" />
<meta itemprop="dateModified" content="2020-11-13T14:05:41+00:00" />
<meta itemprop="wordCount" content="1114">



<meta itemprop="keywords" content="" />
</head>
<body><div class="container"><header>
<h1>Probabilistic Effects.  λθ</h1>
</header>

<div class="content-container">
<main><h1>Fusion for Free</h1>
<p>Free monads are at the heart of algebraic effect handlers, a functional approach for modelling side effects which allows the separation of the syntax and semantics of effectful operations, whilst enabling us to provide multiple different semantics for the same syntax.</p>
<p>The syntax of primitive side-effect operations is captured in a <em>signature functor</em>. The free monad over this functor assembles the syntax for the individual operations into an abstract syntax tree for an effectful program.</p>
<p>The semantics of the individual operations is captured in an algebra, and an effect handler folds the algebra over the syntax tree of the program to interpret it into a semantic domain.</p>
<h3 id="2-algebraic-effect-handlers">2. Algebraic Effect Handlers</h3>
<p>The idea of the algebraic effect handlers approach is to consider the free monad over a particular functor as an AST for an effectful computation. This functor is used to generate the nodes of a free structure whose leaves correspond to variables.</p>
<pre><code>data Free f a where
    Var :: a -&gt; Free f a
    Con :: f (Free f a) -&gt; Free f a
</code></pre><p>Since a value of type <code>Free f a</code> is an inductive structure, we can define a <code>fold</code> for it by providing:</p>
<ul>
<li>A function <code>gen</code> that deals with generation of values from <code>Var x</code>.</li>
<li>An algebra <code>alg</code> that is used to recursively collapse an operation <code>Con op</code>.</li>
</ul>
<pre><code>fold :: Functor f =&gt; (f b -&gt; b) -&gt; (a -&gt; b) -&gt; (Free f a -&gt; b)
fold alg gen (Var x)  = gen x
fold alg gen (Con op) = alg (fmap (fold alg gen) op)
</code></pre><p>Algebraic effect handlers give a semantics to the syntax tree: one way of doing this is by using a fold. The behaviour of folds when composed with other functions is described by fusion laws.</p>
<ul>
<li>The first law describes how certain functions that are precomposed with a fold can be incorporated into a new fold:
<pre><code>fold alg gen · fmap h = fold alg (gen · h)
</code></pre></li>
<li>The second law shows how certain functions that are postcomposed with a fold can be incorporated into a new fold:
<pre><code>k · fold alg gen = fold alg' (k · gen)
</code></pre><p>This law is subject to the condition that:</p>
<pre><code>k · alg = alg' · fmap k
</code></pre></li>
</ul>
<p>The monadic instance of the free monad given below.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">instance</span> <span style="color:#66d9ef">Functor</span> <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">Monad</span> (<span style="color:#66d9ef">Free</span> f) <span style="color:#66d9ef">where</span>
    return x <span style="color:#f92672">=</span> <span style="color:#66d9ef">Var</span> x
    m <span style="color:#f92672">&gt;&gt;=</span> f  <span style="color:#f92672">=</span> fold <span style="color:#66d9ef">Con</span> f m
</code></pre></div><p>Variables are the way of providing a return for the monad. Extending a syntax tree by a means of a function <em>f</em> corresponds to applying that function to the variables found at the leaves of the tree.</p>
<h4 id="21-nondeterminism">2.1 Nondeterminism</h4>
<p>A functor supplies the abstract syntax for the primitive effectful operations in the free monad: to demonsrate, the <code>Nondet</code> functor provides the <code>Or k k</code> syntax for a binary nondeterministic choice primitive. The parameter of type <code>k</code> marks the recursive site of syntax, which indicates where the continuation is after this syntactic fragment has been evaluated.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">Nondet</span> k <span style="color:#66d9ef">where</span>
    <span style="color:#66d9ef">Or</span> <span style="color:#f92672">::</span> k <span style="color:#f92672">-&gt;</span> k <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Nondet</span> k
<span style="color:#66d9ef">instance</span> <span style="color:#66d9ef">Functor</span> <span style="color:#66d9ef">Nondet</span> <span style="color:#66d9ef">where</span>
    fmap f (<span style="color:#66d9ef">Or</span> x y) <span style="color:#f92672">=</span> <span style="color:#66d9ef">Or</span> (f x) (f y)
</code></pre></div><p>This lets us express the syntax tree of a computation that nondeterministically returns <code>True</code> or <code>False</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">coin</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Free</span> <span style="color:#66d9ef">Nondet</span> <span style="color:#66d9ef">Bool</span>
<span style="color:#a6e22e">coin</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">Con</span> (<span style="color:#66d9ef">Or</span> (<span style="color:#66d9ef">Var</span> <span style="color:#66d9ef">True</span>) (<span style="color:#66d9ef">Var</span> <span style="color:#66d9ef">False</span>))
</code></pre></div><p>The syntax is complemented by semantics in the form of effect handlers &ndash; functions which replace the syntax by values from a semantic domain. Using a fold for the free monad is a natural way of expressing such functions.</p>
<p>Here is an effect handler that interprets <code>Nondet</code> in terms of lists of possible outcomes:</p>
<pre><code>handle_Nondet :: Free Nondet a -&gt; [a]
handle_Nondet = fold alg_Nondet gen_Nondet
</code></pre><p>where <code>alg_Nondet</code> is the <code>Nondet</code>-algebra that interprets terms constructed by <code>Or</code> operations:</p>
<pre><code>alg_Nondet :: Nondet [a] -&gt; [a]
alg_Nondet (Or l1 l2) = l1 ++ l2
</code></pre><p>and <code>gen_Nondet</code> interprets variables:</p>
<pre><code>gen_Nondet :: a -&gt; [a]
gen_Nondet x = [x]
</code></pre><p>Generalising away from the details, handlers are usually presented in the following form, where <code>F</code> and <code>H</code> are arbitrary functors determined by the handler:</p>
<pre><code>hdl :: ∀ a . Free F a -&gt; H a
</code></pre><h4 id="22-handler-composition">2.2 Handler Composition</h4>
<p>We consider two classes of scenarios where effect handler composition is involved.</p>
<p><strong>Effect Composition</strong> The first class of scenarios is where multiple effects are combined in the same program; to this end, we compose signatures and handlers.</p>
<p>The coproduct functor <code>f + g</code> makes it easy to compose functors.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">data</span> (<span style="color:#f92672">+</span>) f g a <span style="color:#66d9ef">where</span>
    <span style="color:#66d9ef">Inl</span> <span style="color:#f92672">::</span> f a <span style="color:#f92672">-&gt;</span> (f <span style="color:#f92672">+</span> g) a
    <span style="color:#66d9ef">Inr</span> <span style="color:#f92672">::</span> g a <span style="color:#f92672">-&gt;</span> (f <span style="color:#f92672">+</span> g) a

<span style="color:#66d9ef">instance</span> (<span style="color:#66d9ef">Functor</span> f, <span style="color:#66d9ef">Functor</span> g) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">Functor</span> (f <span style="color:#f92672">+</span> g) <span style="color:#66d9ef">where</span>
    fmap f (<span style="color:#66d9ef">Inl</span> s) <span style="color:#f92672">=</span> <span style="color:#66d9ef">Inl</span> (fmap f s)
    fmap f (<span style="color:#66d9ef">Inr</span> s) <span style="color:#f92672">=</span> <span style="color:#66d9ef">Inr</span> (fmap f s)
</code></pre></div><p>The free monad of a coproduct functor is then a tree where each node can be built from syntax from either <code>f</code> or <code>g</code>.</p>
<p>Composing handlers is easy too: if the handlers are written in a compositional
style, then function composition does the trick.</p>
<p>Given that a normal effect handler for the functor <code>F</code> has the general form:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">hdl</span> <span style="color:#f92672">::</span> <span style="color:#960050;background-color:#1e0010">∀</span> a <span style="color:#f92672">.</span> <span style="color:#66d9ef">Free</span> <span style="color:#66d9ef">F</span> a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">H</span> a
</code></pre></div><p>A compositional handler for the functor <code>F</code> then has a signature of the form:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">hdl</span> <span style="color:#f92672">::</span> <span style="color:#960050;background-color:#1e0010">∀</span> g a <span style="color:#f92672">.</span> <span style="color:#66d9ef">Free</span> (<span style="color:#66d9ef">F</span> <span style="color:#f92672">+</span> g) a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">H1</span> (<span style="color:#66d9ef">Free</span> g (<span style="color:#66d9ef">G1</span> a))
</code></pre></div><p>This processes only the <code>F</code>-nodes in the AST and leaves the <code>g</code>-nodes as they
are. Hence the result of the compositional handler is a new, typically smaller, AST with only <code>g</code>-nodes.</p>
<ul>
<li>The variables of type <code>G1 a</code> in the resulting AST are derived from the variables of type <code>a</code> in the original AST as well as from the processed operations (the context <code>G1</code> is due to the <code>gen</code> function which interprets variables).</li>
<li>Moreover, the new AST may be embedded in a context <code>H1</code>.</li>
</ul>
<p>For example, the compositional nondeterminism handler is defined as follows:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">handle_Nondet</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Functor</span> g <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">Free</span> (<span style="color:#66d9ef">Nondet</span> <span style="color:#f92672">+</span> g) a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Free</span> g [a]
<span style="color:#a6e22e">handle_Nondet</span> <span style="color:#f92672">=</span> fold (alg_Nondet <span style="color:#960050;background-color:#1e0010">▽</span> <span style="color:#66d9ef">Con</span>) gen_Nondet
</code></pre></div><p>where <code>F</code> is <code>Nondet</code>, <code>G1</code> is <code>[]</code>, and implicitly <code>H1</code> is <code>Id</code>.</p>
<p>In here, the variables are handled with the monadified version of the previous <code>gen_Nondet</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">gen_Nondet</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Functor</span> g <span style="color:#f92672">=&gt;</span> a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Free</span> g [a]
<span style="color:#a6e22e">gen_Nondet</span> x <span style="color:#f92672">=</span> <span style="color:#66d9ef">Var</span> [x]
</code></pre></div><p>The <code>g</code> nodes are handled by a <code>Con</code> algebra, which essentially leaves them untouched. The <code>Nondet</code> nodes are handled by the <code>alg_Nondet</code> algebra, which is a monadified version of the previous <code>alg_Nondet</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">alg_Nondet</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Functor</span> g <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">Nondet</span> (<span style="color:#66d9ef">Free</span> g [a]) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Free</span> g [a]
<span style="color:#a6e22e">alg_Nondet</span> (<span style="color:#66d9ef">Or</span> ml1 ml2) <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">do</span> l1 <span style="color:#f92672">&lt;-</span> ml1
       l2 <span style="color:#f92672">&lt;-</span> ml2
       <span style="color:#66d9ef">Var</span> (l1 <span style="color:#f92672">++</span> l2)
</code></pre></div><div class="edit-meta">
Last updated on 13 Nov 2020


<br>
Published on 13 Nov 2020
<br></div><nav class="pagination"><a class="nav nav-prev" href="https://probabilistic-effects.github.io/papers/freer-monads/" title="Freer Monads, More Extensible Effects"><i class="fas fa-arrow-left" aria-hidden="true"></i> Prev - Freer Monads, More Extensible Effects</a>
<a class="nav nav-next" href="https://probabilistic-effects.github.io/research/" title="Research">Next - Research <i class="fas fa-arrow-right" aria-hidden="true"></i></a>
</nav><footer><p class="powered">Powered by <a href="https://gohugo.io">Hugo</a>. Theme by <a href="https://themes.gohugo.io/hugo-theme-techdoc/">TechDoc</a>. Designed by <a href="https://github.com/thingsym/hugo-theme-techdoc">Thingsym</a>.</p>
</footer>
</main>
<div class="sidebar">

<nav class="open-menu">
<ul>
<li class=""><a href="https://probabilistic-effects.github.io/">Home</a></li>

<li class=""><a href="https://probabilistic-effects.github.io/approaches/">Approaches</a>
  
<ul class="sub-menu">
<li class=""><a href="https://probabilistic-effects.github.io/approaches/inlining-monad-bayes/">Inlining Monad Bayes</a></li>
</ul>
  
</li>

<li class="parent"><a href="https://probabilistic-effects.github.io/papers/">Papers</a>
  
<ul class="sub-menu">
<li class=""><a href="https://probabilistic-effects.github.io/papers/freer-monads/">Freer Monads, More Extensible Effects</a></li>
<li class="active"><a href="https://probabilistic-effects.github.io/papers/fusion-for-free/">Fusion for Free</a></li>
</ul>
  
</li>

<li class=""><a href="https://probabilistic-effects.github.io/research/">Research</a>
  
<ul class="sub-menu">
<li class=""><a href="https://probabilistic-effects.github.io/research/research-journal/">Research Journal</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/research/approaches-for-monad-bayes/">Potential Approaches to Improving Monad Bayes</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/research/effects-for-less/">Effects for Less</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/research/literature-review/">Literature Review</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/research/parsley-case-study/">Case Study: Optimising Parsley</a></li>
</ul>
  
</li>

<li class=""><a href="https://probabilistic-effects.github.io/monad-bayes/">Monad Bayes</a>
  
<ul class="sub-menu">
<li class=""><a href="https://probabilistic-effects.github.io/monad-bayes/inference-transformers/">Inference Transformers</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/monad-bayes/pmmh-hmm/">Implementing HMM Simulation and Inference (using PMMH)</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/monad-bayes/conditioning-scoring/">How Conditioning and Scoring Works</a></li>
</ul>
  
</li>

<li class=""><a href="https://probabilistic-effects.github.io/tooling/">Tooling</a>
  
<ul class="sub-menu">
<li class=""><a href="https://probabilistic-effects.github.io/tooling/cabal/">Cabal</a></li>
</ul>
  
</li>

<li class=""><a href="https://probabilistic-effects.github.io/benchmarking/">Benchmarking</a>
  
<ul class="sub-menu">
<li class=""><a href="https://probabilistic-effects.github.io/benchmarking/benchmark-log/">Benchmark Log</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/benchmarking/benchmarking-profiling/">How to Benchmark and Profile</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/benchmarking/monad-bayes-components/">Relevant Components of Monad Bayes for Profiling</a></li>
</ul>
  
</li>

<li class=""><a href="https://probabilistic-effects.github.io/background/">Background</a>
  
<ul class="sub-menu">
<li class=""><a href="https://probabilistic-effects.github.io/background/staging/">Staging</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/background/smc-pmmh/">SMC and PMMH</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/background/handrolling/">Handrolling Monad Transformer Stacks</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/background/mtl/">MTL</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/background/mcmc-mh/">MCMC and MH</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/background/markov-chain/">Markov Chains</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/background/hidden-markov-model/">Hidden Markov Model</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/background/delimited-continuations/">Delimited Continuations</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/background/haskell-core/">Haskell Core</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/background/inlining/">Inlining</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/background/specialisation/">Specialisation</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/background/continuations/">Continuations</a></li>
</ul>
  
</li>
</ul>
</nav>



<div class="sidebar-footer"></div>
</div>

</div><a href="#" id="backtothetop-fixed" class="backtothetop"
 data-backtothetop-duration="600"
 data-backtothetop-easing="easeOutQuart"
 data-backtothetop-fixed-fadeIn="1000"
 data-backtothetop-fixed-fadeOut="1000"
 data-backtothetop-fixed-bottom="10"
 data-backtothetop-fixed-right="20">
<span class="fa-layers fa-fw">
<i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i>
</span></a>
</div>
</body>
</html>

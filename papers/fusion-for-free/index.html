<!DOCTYPE html>
<html lang="en-us">
<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>Fusion for Free - Probabilistic Effects.  λθ</title>
<meta name="generator" content="Hugo 0.78.2" />
<link href="https://probabilistic-effects.github.io//index.xml" rel="alternate" type="application/rss+xml">
<link rel="canonical" href="https://probabilistic-effects.github.io/papers/fusion-for-free/">
<link rel="stylesheet" href="https://probabilistic-effects.github.io/css/theme.min.css">
<script src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script>
<link rel="stylesheet" href="https://probabilistic-effects.github.io/css/chroma.min.css">
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script>
<script src="https://probabilistic-effects.github.io/js/bundle.js"></script><style>
:root {}
</style>
<meta property="og:title" content="Fusion for Free" />
<meta property="og:description" content="Free monads are at the heart of algebraic effect handlers, a functional approach for modelling side effects which allows the separation of the syntax and semantics of effectful operations, whilst enabling us to provide multiple different semantics for the same syntax.
The syntax of primitive side-effect operations is captured in a signature functor. The free monad over this functor assembles the syntax for the individual operations into an abstract syntax tree for an effectful program." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://probabilistic-effects.github.io/papers/fusion-for-free/" />
<meta property="article:published_time" content="2020-11-13T14:05:41+00:00" />
<meta property="article:modified_time" content="2020-11-13T14:05:41+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Fusion for Free"/>
<meta name="twitter:description" content="Free monads are at the heart of algebraic effect handlers, a functional approach for modelling side effects which allows the separation of the syntax and semantics of effectful operations, whilst enabling us to provide multiple different semantics for the same syntax.
The syntax of primitive side-effect operations is captured in a signature functor. The free monad over this functor assembles the syntax for the individual operations into an abstract syntax tree for an effectful program."/>
<meta itemprop="name" content="Fusion for Free">
<meta itemprop="description" content="Free monads are at the heart of algebraic effect handlers, a functional approach for modelling side effects which allows the separation of the syntax and semantics of effectful operations, whilst enabling us to provide multiple different semantics for the same syntax.
The syntax of primitive side-effect operations is captured in a signature functor. The free monad over this functor assembles the syntax for the individual operations into an abstract syntax tree for an effectful program.">
<meta itemprop="datePublished" content="2020-11-13T14:05:41+00:00" />
<meta itemprop="dateModified" content="2020-11-13T14:05:41+00:00" />
<meta itemprop="wordCount" content="2403">



<meta itemprop="keywords" content="" />
</head>
<body><div class="container"><header>
<h1>Probabilistic Effects.  λθ</h1>
</header>

<div class="content-container">
<main><h1>Fusion for Free</h1>
<p>Free monads are at the heart of algebraic effect handlers, a functional approach for modelling side effects which allows the separation of the syntax and semantics of effectful operations, whilst enabling us to provide multiple different semantics for the same syntax.</p>
<p>The syntax of primitive side-effect operations is captured in a <em>signature functor</em>. The free monad over this functor assembles the syntax for the individual operations into an abstract syntax tree for an effectful program.</p>
<p>The semantics of the individual operations is captured in an algebra, and an effect handler folds the algebra over the syntax tree of the program to interpret it into a semantic domain.</p>
<h3 id="2-algebraic-effect-handlers">2. Algebraic Effect Handlers</h3>
<p>The idea of the algebraic effect handlers approach is to consider the free monad over a particular functor as an AST for an effectful computation. This functor is used to generate the nodes of a free structure whose leaves correspond to variables.</p>
<pre><code>data Free f a where
    Var :: a -&gt; Free f a
    Con :: f (Free f a) -&gt; Free f a
</code></pre><p>Since a value of type <code>Free f a</code> is an inductive structure, we can define a <code>fold</code> for it by providing:</p>
<ul>
<li>A function <code>gen</code> that deals with generation of values from <code>Var x</code>.</li>
<li>An algebra <code>alg</code> that is used to recursively collapse an operation <code>Con op</code>.</li>
</ul>
<pre><code>fold :: Functor f =&gt; (f b -&gt; b) -&gt; (a -&gt; b) -&gt; (Free f a -&gt; b)
fold alg gen (Var x)  = gen x
fold alg gen (Con op) = alg (fmap (fold alg gen) op)
</code></pre><p>Algebraic effect handlers give a semantics to the syntax tree: one way of doing this is by using a fold. The behaviour of folds when composed with other functions is described by fusion laws.</p>
<ul>
<li>The first law describes how certain functions that are precomposed with a fold can be incorporated into a new fold:
<pre><code>fold alg gen · fmap h = fold alg (gen · h)
</code></pre></li>
<li>The second law shows how certain functions that are postcomposed with a fold can be incorporated into a new fold:
<pre><code>k · fold alg gen = fold alg' (k · gen)
</code></pre><p>This law is subject to the condition that:</p>
<pre><code>k · alg = alg' · fmap k
</code></pre></li>
</ul>
<p>The monadic instance of the free monad given below.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">instance</span> <span style="color:#66d9ef">Functor</span> <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">Monad</span> (<span style="color:#66d9ef">Free</span> f) <span style="color:#66d9ef">where</span>
    return x <span style="color:#f92672">=</span> <span style="color:#66d9ef">Var</span> x
    m <span style="color:#f92672">&gt;&gt;=</span> f  <span style="color:#f92672">=</span> fold <span style="color:#66d9ef">Con</span> f m
</code></pre></div><p>Variables are the way of providing a return for the monad. Extending a syntax tree by a means of a function <em>f</em> corresponds to applying that function to the variables found at the leaves of the tree.</p>
<h4 id="21-nondeterminism">2.1 Nondeterminism</h4>
<p>A functor supplies the abstract syntax for the primitive effectful operations in the free monad: to demonsrate, the <code>Nondet</code> functor provides the <code>Or k k</code> syntax for a binary nondeterministic choice primitive. The parameter of type <code>k</code> marks the recursive site of syntax, which indicates where the continuation is after this syntactic fragment has been evaluated.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">Nondet</span> k <span style="color:#66d9ef">where</span>
    <span style="color:#66d9ef">Or</span> <span style="color:#f92672">::</span> k <span style="color:#f92672">-&gt;</span> k <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Nondet</span> k
<span style="color:#66d9ef">instance</span> <span style="color:#66d9ef">Functor</span> <span style="color:#66d9ef">Nondet</span> <span style="color:#66d9ef">where</span>
    fmap f (<span style="color:#66d9ef">Or</span> x y) <span style="color:#f92672">=</span> <span style="color:#66d9ef">Or</span> (f x) (f y)
</code></pre></div><p>This lets us express the syntax tree of a computation that nondeterministically returns <code>True</code> or <code>False</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">coin</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Free</span> <span style="color:#66d9ef">Nondet</span> <span style="color:#66d9ef">Bool</span>
<span style="color:#a6e22e">coin</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">Con</span> (<span style="color:#66d9ef">Or</span> (<span style="color:#66d9ef">Var</span> <span style="color:#66d9ef">True</span>) (<span style="color:#66d9ef">Var</span> <span style="color:#66d9ef">False</span>))
</code></pre></div><p>The syntax is complemented by semantics in the form of effect handlers &ndash; functions which replace the syntax by values from a semantic domain. Using a fold for the free monad is a natural way of expressing such functions.</p>
<p>Here is an effect handler that interprets <code>Nondet</code> in terms of lists of possible outcomes:</p>
<pre><code>handle_Nondet :: Free Nondet a -&gt; [a]
handle_Nondet = fold alg_Nondet gen_Nondet
</code></pre><p>where <code>alg_Nondet</code> is the <code>Nondet</code>-algebra that interprets terms constructed by <code>Or</code> operations:</p>
<pre><code>alg_Nondet :: Nondet [a] -&gt; [a]
alg_Nondet (Or l1 l2) = l1 ++ l2
</code></pre><p>and <code>gen_Nondet</code> interprets variables:</p>
<pre><code>gen_Nondet :: a -&gt; [a]
gen_Nondet x = [x]
</code></pre><p>Generalising away from the details, handlers are usually presented in the following form, where <code>F</code> and <code>H</code> are arbitrary functors determined by the handler:</p>
<pre><code>hdl :: ∀ a . Free F a -&gt; H a
</code></pre><h4 id="22-handler-composition">2.2 Handler Composition</h4>
<p>We consider two classes of scenarios where effect handler composition is involved.</p>
<p><strong>Effect Composition</strong> The first class of scenarios is where multiple effects are combined in the same program; to this end, we compose signatures and handlers.</p>
<p>The coproduct functor <code>f + g</code> makes it easy to compose functors.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">data</span> (<span style="color:#f92672">+</span>) f g a <span style="color:#66d9ef">where</span>
    <span style="color:#66d9ef">Inl</span> <span style="color:#f92672">::</span> f a <span style="color:#f92672">-&gt;</span> (f <span style="color:#f92672">+</span> g) a
    <span style="color:#66d9ef">Inr</span> <span style="color:#f92672">::</span> g a <span style="color:#f92672">-&gt;</span> (f <span style="color:#f92672">+</span> g) a

<span style="color:#66d9ef">instance</span> (<span style="color:#66d9ef">Functor</span> f, <span style="color:#66d9ef">Functor</span> g) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">Functor</span> (f <span style="color:#f92672">+</span> g) <span style="color:#66d9ef">where</span>
    fmap f (<span style="color:#66d9ef">Inl</span> s) <span style="color:#f92672">=</span> <span style="color:#66d9ef">Inl</span> (fmap f s)
    fmap f (<span style="color:#66d9ef">Inr</span> s) <span style="color:#f92672">=</span> <span style="color:#66d9ef">Inr</span> (fmap f s)
</code></pre></div><p>The free monad of a coproduct functor is then a tree where each node can be built from syntax from either <code>f</code> or <code>g</code>.</p>
<p>Composing handlers is easy too: if the handlers are written in a compositional
style, then function composition does the trick.</p>
<p>Given that a normal effect handler for the functor <code>F</code> has the general form:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">hdl</span> <span style="color:#f92672">::</span> <span style="color:#960050;background-color:#1e0010">∀</span> a <span style="color:#f92672">.</span> <span style="color:#66d9ef">Free</span> <span style="color:#66d9ef">F</span> a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">H</span> a
</code></pre></div><p>A compositional handler for the functor <code>F</code> then has a signature of the form:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">hdl</span> <span style="color:#f92672">::</span> <span style="color:#960050;background-color:#1e0010">∀</span> g a <span style="color:#f92672">.</span> <span style="color:#66d9ef">Free</span> (<span style="color:#66d9ef">F</span> <span style="color:#f92672">+</span> g) a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">H1</span> (<span style="color:#66d9ef">Free</span> g (<span style="color:#66d9ef">G1</span> a))
</code></pre></div><p>This processes only the <code>F</code>-nodes in the AST and leaves the <code>g</code>-nodes as they
are. Hence the result of the compositional handler is a new, typically smaller, AST with only <code>g</code>-nodes.</p>
<ul>
<li>The variables of type <code>G1 a</code> in the resulting AST are derived from the variables of type <code>a</code> in the original AST as well as from the processed operations (the context <code>G1</code> is due to the <code>gen</code> function which interprets variables).</li>
<li>Moreover, the new AST may be embedded in a context <code>H1</code>.</li>
</ul>
<p>As an example of an effect signature, the compositional nondeterminism handler is defined as follows:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">handle_Nondet</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Functor</span> g <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">Free</span> (<span style="color:#66d9ef">Nondet</span> <span style="color:#f92672">+</span> g) a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Free</span> g [a]
<span style="color:#a6e22e">handle_Nondet</span> <span style="color:#f92672">=</span> fold (alg_Nondet <span style="color:#960050;background-color:#1e0010">▽</span> <span style="color:#66d9ef">Con</span>) gen_Nondet
</code></pre></div><p>where given the general handler form <code>hdl :: ∀ g a . Free (F + g) a -&gt; H1 (Free g (G1 a))</code> &ndash; <code>F</code> is <code>Nondet</code>, <code>G1</code> is <code>[]</code>, and implicitly <code>H1</code> is <code>Id</code>.</p>
<p>In here, the variables are handled with the monadified version of the previous <code>gen_Nondet</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">gen_Nondet</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Functor</span> g <span style="color:#f92672">=&gt;</span> a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Free</span> g [a]
<span style="color:#a6e22e">gen_Nondet</span> x <span style="color:#f92672">=</span> <span style="color:#66d9ef">Var</span> [x]
</code></pre></div><p>The <code>g</code> nodes are handled by a <code>Con</code> algebra, which essentially leaves them untouched.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">Con</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Functor</span> g <span style="color:#f92672">=&gt;</span> g (<span style="color:#66d9ef">Free</span> g a) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Free</span> g a
</code></pre></div><p>The <code>Nondet</code> nodes are handled by the <code>alg_Nondet</code> algebra, which is a monadified version of the previous <code>alg_Nondet</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">alg_Nondet</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Functor</span> g <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">Nondet</span> (<span style="color:#66d9ef">Free</span> g [a]) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Free</span> g [a]
<span style="color:#a6e22e">alg_Nondet</span> (<span style="color:#66d9ef">Or</span> ml1 ml2) <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">do</span> l1 <span style="color:#f92672">&lt;-</span> ml1
       l2 <span style="color:#f92672">&lt;-</span> ml2
       <span style="color:#66d9ef">Var</span> (l1 <span style="color:#f92672">++</span> l2)
</code></pre></div><p>The junction combinator <code>(▽)</code> composes the algebras for the two kinds of nodes.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">(<span style="color:#960050;background-color:#1e0010">▽</span>) <span style="color:#f92672">::</span> (f b <span style="color:#f92672">-&gt;</span> b) <span style="color:#f92672">-&gt;</span> (g b <span style="color:#f92672">-&gt;</span> b) <span style="color:#f92672">-&gt;</span> ((f <span style="color:#f92672">+</span> g) b <span style="color:#f92672">-&gt;</span> b)
(<span style="color:#960050;background-color:#1e0010">▽</span>) alg_f alg_g (<span style="color:#66d9ef">Inl</span> s) <span style="color:#f92672">=</span> alg_f s
(<span style="color:#960050;background-color:#1e0010">▽</span>) alg_f alg_g (<span style="color:#66d9ef">Inr</span> s) <span style="color:#f92672">=</span> alg_g s
</code></pre></div><p>In the definition of <code>handler_Nondet</code>, we use <code>alg_Nondet ▽ Con</code>. Since the functor in question is <code>Nondet + g</code>, the values constructed by <code>Nondet</code> are handled by <code>alg_Nondet</code>, and the values constructed by <code>g</code> are left untouched (since the definition of fold unwraps one level of <code>Con</code> but using the <code>Con</code> as an algebra then replaces it with a <code>Con</code> again).</p>
<p>As another example of an effect signature is that of state.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">State</span> s k <span style="color:#66d9ef">where</span>
    <span style="color:#66d9ef">Put</span> <span style="color:#f92672">::</span> s <span style="color:#f92672">-&gt;</span> k <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">State</span> s k
    <span style="color:#66d9ef">Get</span> <span style="color:#f92672">::</span> (s <span style="color:#f92672">-&gt;</span> k) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">State</span> s k

<span style="color:#66d9ef">instance</span> <span style="color:#66d9ef">Functor</span> (<span style="color:#66d9ef">State</span> s) <span style="color:#66d9ef">where</span>
    fmap f (<span style="color:#66d9ef">Put</span> s k) <span style="color:#f92672">=</span> <span style="color:#66d9ef">Put</span> s (f k)
    fmap f (<span style="color:#66d9ef">Get</span> k)   <span style="color:#f92672">=</span> <span style="color:#66d9ef">Get</span> (f <span style="color:#960050;background-color:#1e0010">·</span> k)
</code></pre></div><p>The compositional handler for state is defined as follows:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">handle_State</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Functor</span> g <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">Free</span> (<span style="color:#66d9ef">State</span> s <span style="color:#f92672">+</span> g) a <span style="color:#f92672">-&gt;</span> (s <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Free</span> g a)
<span style="color:#a6e22e">handle_State</span> <span style="color:#f92672">=</span> fold (alg_State <span style="color:#960050;background-color:#1e0010">▽</span> con_State) gen_State
</code></pre></div><p>where given the general handler form <code>hdl :: ∀ g a . Free (F + g) a -&gt; H1 (Free g (G1 a))</code> &ndash; <code>F</code> is <code>State s</code>, <code>H1</code> is <code>s -&gt; -</code>, and implicitly <code>G1</code> is <code>Id</code>.</p>
<p>In here, the variables are handled with <code>gen_State</code>. A variable <code>x</code> is replaced by a version that ignores any incoming state parameter <code>s</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">gen_State</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Functor</span> g <span style="color:#f92672">=&gt;</span> a <span style="color:#f92672">-&gt;</span> (s <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Free</span> g a)
<span style="color:#a6e22e">gen_State</span> x s <span style="color:#f92672">=</span> <span style="color:#66d9ef">Var</span> x
</code></pre></div><p>The <code>State</code> nodes are handled by the <code>alg_State</code> algebra. This outputs a function which when given a state, the continuation <code>k</code> proceeds by using the appropriate state: if the syntax is a <code>Put s' k</code>, then the new state is <code>s'</code>, otherwise the syntax is <code>Get k</code>, in which case the state is left unchanged and passed as <code>s</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">alg_State</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Functor</span> g <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">State</span> s (s <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Free</span> g a) <span style="color:#f92672">-&gt;</span> (s <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Free</span> g a)
<span style="color:#a6e22e">alg_State</span> (<span style="color:#66d9ef">Put</span> s&#39; k) <span style="color:#f92672">=</span> <span style="color:#a6e22e">\</span>s <span style="color:#f92672">-&gt;</span> k s&#39;
<span style="color:#a6e22e">alg_State</span> (<span style="color:#66d9ef">Get</span> (k <span style="color:#f92672">::</span> s <span style="color:#f92672">-&gt;</span> (s <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Free</span> g a)))  <span style="color:#f92672">=</span> <span style="color:#a6e22e">\</span>s <span style="color:#f92672">-&gt;</span> k s s
</code></pre></div><p>The <code>g</code> nodes are handled by the <code>con_State</code> algebra. This takes the extra state parameter <code>s</code> into account.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">con_State</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Functor</span> g <span style="color:#f92672">=&gt;</span> g (s <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Free</span> g a) <span style="color:#f92672">-&gt;</span> (s <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Free</span> g a)
<span style="color:#a6e22e">con_State</span> op <span style="color:#f92672">=</span> <span style="color:#a6e22e">\</span>s <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Con</span> (fmap (<span style="color:#a6e22e">\</span>(m <span style="color:#f92672">::</span> s <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Free</span> g a) <span style="color:#f92672">-&gt;</span> m s) op)
</code></pre></div><p>To demonstrate effect composition, we can put <code>Nondet</code> and <code>State</code> together and handle them both. Before we do so, we also need a base case for the composition, which is the empty signature <code>Void</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">Void</span> k

<span style="color:#66d9ef">instance</span> <span style="color:#66d9ef">Functor</span> <span style="color:#66d9ef">Void</span>
</code></pre></div><p>The <code>Void</code> handler only provides a variable case since the signature has no constructors. In fact, a <code>Free Void</code> term can only be a <code>Var x</code>, so <code>x</code> is immediately output using the identity function (recall that <code>fold alg gen (Var x) = gen x</code>).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">handle_Void</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Free</span> <span style="color:#66d9ef">Void</span> a <span style="color:#f92672">-&gt;</span> a
<span style="color:#a6e22e">handle_Void</span> <span style="color:#f92672">=</span> fold <span style="color:#960050;background-color:#1e0010">⊥</span> id
</code></pre></div><p>Finally, we can put together a composite handler for programs that feature both non-determinism and state. The signature of such programs is the composition of the three basic signatures:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">type</span> <span style="color:#66d9ef">Σ</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">Nondet</span> <span style="color:#f92672">+</span> (<span style="color:#66d9ef">State</span> <span style="color:#66d9ef">Int</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">Void</span>)
</code></pre></div><p>The handler is the composition of the three handlers, working from the left-most functor in the signature:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">handle_Σ</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Free</span> <span style="color:#66d9ef">Σ</span> a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Int</span> [a]
<span style="color:#a6e22e">handle_Σ</span> prog <span style="color:#f92672">=</span> handle_Void <span style="color:#f92672">.</span> (handle_State <span style="color:#f92672">.</span> handle_Nondet) prog
</code></pre></div><p><strong>Effect Delegation</strong> Another important class of applications are those where a handler expresses the complex semantics of particular operations in terms of more primitive effects.</p>
<p>For example, the syntax of the writer effect is captured by the folowing functor, where <code>w</code> is a parameter that represents the type of values that are written to the log.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">Writer</span> w k <span style="color:#66d9ef">where</span>
    <span style="color:#66d9ef">Tell</span> <span style="color:#f92672">::</span> w <span style="color:#f92672">-&gt;</span> k <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Writer</span> w k

<span style="color:#66d9ef">instance</span> <span style="color:#66d9ef">Functor</span> (<span style="color:#66d9ef">Writer</span> w) <span style="color:#66d9ef">where</span>
    fmap f (<span style="color:#66d9ef">Tell</span> w k) <span style="color:#f92672">=</span> <span style="color:#66d9ef">Tell</span> w (f k)
</code></pre></div><p>The following logging handler for state records every update of the state, by means of the <code>Writer</code> effect. For the <code>Put</code> cases, we take our previous definition <code>\s -&gt; k s'</code> of <code>alg_State</code>, but wrap the result <code>k s'</code> in a <code>Free (Writer String + Void)</code> monad, by using <code>Con (Inl (Tell &quot;put&quot; _))</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">handle_LogState</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Free</span> (<span style="color:#66d9ef">State</span> s) a <span style="color:#f92672">-&gt;</span> s <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Free</span> (<span style="color:#66d9ef">Writer</span> <span style="color:#66d9ef">String</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">Void</span>) a
<span style="color:#a6e22e">handle_LogState</span> <span style="color:#f92672">=</span> fold alg_LogState gen_State

<span style="color:#a6e22e">alg_LogState</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">State</span> s (s <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Free</span> (<span style="color:#66d9ef">Writer</span> <span style="color:#66d9ef">String</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">Void</span>) a)
                <span style="color:#f92672">-&gt;</span> s <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Free</span> (<span style="color:#66d9ef">Writer</span> <span style="color:#66d9ef">String</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">Void</span>) a
<span style="color:#75715e">-- alg_State (Put s&#39; k) = \s -&gt; k s&#39;</span>
<span style="color:#a6e22e">alg_LogState</span> (<span style="color:#66d9ef">Put</span> s&#39; k) <span style="color:#f92672">=</span> <span style="color:#a6e22e">\</span>s <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Con</span> (<span style="color:#66d9ef">Inl</span> (<span style="color:#66d9ef">Tell</span> <span style="color:#e6db74">&#34;put&#34;</span> (k s&#39;)))
<span style="color:#75715e">-- alg_State (Get k)    = \s -&gt; k s s</span>
<span style="color:#a6e22e">alg_LogState</span> (<span style="color:#66d9ef">Get</span> k)    <span style="color:#f92672">=</span> <span style="color:#a6e22e">\</span>s <span style="color:#f92672">-&gt;</span> k s s
</code></pre></div><p>A semantics for the writer effect can be given by the following handler, where <code>w</code> is constrained to be a member of the <code>Monoid</code> typeclass.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">handle_Writer</span> <span style="color:#f92672">::</span> (<span style="color:#66d9ef">Functor</span> g, <span style="color:#66d9ef">Monoid</span> w) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">Free</span> (<span style="color:#66d9ef">Writer</span> w <span style="color:#f92672">+</span> g) a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Free</span> g (w, a)
<span style="color:#a6e22e">handle_Writer</span> <span style="color:#f92672">=</span> fold (alg_Writer <span style="color:#960050;background-color:#1e0010">▽</span> <span style="color:#66d9ef">Con</span>) gen_Writer
</code></pre></div><p>The variables are handled by <code>gen_Writer</code>, which pairs the variable with the unit of the writer&rsquo;s log monoid, before embedding it into the monad <code>m2</code> (which is the monad that we are logging e.g. the state monad).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">gen_Writer</span> <span style="color:#f92672">::</span> (<span style="color:#66d9ef">Monad</span> m2, <span style="color:#66d9ef">Monoid</span> w) <span style="color:#f92672">=&gt;</span> a <span style="color:#f92672">-&gt;</span> m2 (w, a)
<span style="color:#a6e22e">gen_Writer</span> x <span style="color:#f92672">=</span> return (mempty, x)
</code></pre></div><p>The <code>Writer</code> nodes are handled by the <code>alg_Writer</code> handler, which when encounters a <code>Tell w1 k</code> operation, the continuation <code>k :: m2 (w, a)</code> (which is already the correct return type) is <code>&gt;&gt;=</code>&rsquo;d to a function which simply appends the log <code>w1</code> to any generated logs.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">alg_Writer</span> <span style="color:#f92672">::</span> (<span style="color:#66d9ef">Monad</span> m2, <span style="color:#66d9ef">Monoid</span> w) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">Writer</span> w (m2 (w, a)) <span style="color:#f92672">-&gt;</span> m2 (w, a)
<span style="color:#a6e22e">alg_Writer</span> (<span style="color:#66d9ef">Tell</span> w1 k) <span style="color:#f92672">=</span> k <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#a6e22e">\</span>(w2, x) <span style="color:#f92672">-&gt;</span> return (w1 `mappend` w2, x)
</code></pre></div><p>To see this machinery in action, consider the following program that uses state (to add the sum of the sequence up to <code>n</code> onto the current state <code>s</code>):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">program</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Int</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Free</span> (<span style="color:#66d9ef">State</span> <span style="color:#66d9ef">Int</span>) <span style="color:#66d9ef">Int</span>
<span style="color:#a6e22e">program</span> n
    <span style="color:#f92672">|</span> n <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>    <span style="color:#f92672">=</span> <span style="color:#66d9ef">Con</span> (<span style="color:#66d9ef">Get</span> <span style="color:#66d9ef">Var</span>)
    <span style="color:#f92672">|</span> otherwise <span style="color:#f92672">=</span> <span style="color:#66d9ef">Con</span> (<span style="color:#66d9ef">Get</span> (<span style="color:#a6e22e">\</span>s <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Con</span> (<span style="color:#66d9ef">Put</span> (s <span style="color:#f92672">+</span> n) (program (n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)))))
</code></pre></div><p>This is then simply evaluated by running handlers in sequence.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">example</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Int</span> <span style="color:#f92672">-&gt;</span> (<span style="color:#66d9ef">String</span>, <span style="color:#66d9ef">Int</span>)
<span style="color:#a6e22e">example</span> n <span style="color:#f92672">=</span> (handle_Void <span style="color:#f92672">.</span> handle_Writer <span style="color:#f92672">.</span> handle_LogState (program n)) <span style="color:#ae81ff">0</span>
</code></pre></div><p>To fully interpret a stateful program, we must first run <code>handle_LogState</code> which interprets the <code>Tell</code> operations by generating a tree with <code>Writer String</code> syntax. This generated syntax is then handled with the <code>handle_Writer</code> handler.</p>
<h3 id="3-fusion">3. Fusion</h3>
<p>The composition of two handlers produces an intermediate abstract syntax tree. We aim to answer the question, &ldquo;how can we use the two handlers into a single one that does not involve an intermediate tree?&rdquo;.</p>
<p>More concretely, given two handlers of the form:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">handler_1</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Free</span> <span style="color:#66d9ef">F1</span> a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">H1</span> (<span style="color:#66d9ef">Free</span> <span style="color:#66d9ef">F2</span> (<span style="color:#66d9ef">G1</span> a))
<span style="color:#a6e22e">handler_1</span> <span style="color:#f92672">=</span> fold alg_1 gen_1

<span style="color:#a6e22e">handler_2</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Free</span> <span style="color:#66d9ef">F2</span> a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">H2</span> a
<span style="color:#a6e22e">handler_2</span> <span style="color:#f92672">=</span> fold alg_2 gen_2
</code></pre></div><p><code>F1</code> and <code>F2</code> are signature functors. <code>H1</code>, <code>G1</code>, and <code>H2</code> are arbitrary functors. Our goal is to obtain a combined handler:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">pipeline_12</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Free</span> <span style="color:#66d9ef">F1</span> a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">H1</span> (<span style="color:#66d9ef">H2</span> (<span style="color:#66d9ef">G1</span> a))
<span style="color:#a6e22e">pipeline_12</span> <span style="color:#f92672">=</span> fold alg_12 gen_12
</code></pre></div><p>such that:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">fmap</span> handler_2 <span style="color:#f92672">.</span> handler_1 <span style="color:#f92672">=</span> pipeline_12
</code></pre></div><div class="edit-meta">
Last updated on 13 Nov 2020


<br>
Published on 13 Nov 2020
<br></div><nav class="pagination"><a class="nav nav-prev" href="https://probabilistic-effects.github.io/papers/freer-monads/" title="Freer Monads, More Extensible Effects"><i class="fas fa-arrow-left" aria-hidden="true"></i> Prev - Freer Monads, More Extensible Effects</a>
<a class="nav nav-next" href="https://probabilistic-effects.github.io/research/" title="Research">Next - Research <i class="fas fa-arrow-right" aria-hidden="true"></i></a>
</nav><footer><p class="powered">Powered by <a href="https://gohugo.io">Hugo</a>. Theme by <a href="https://themes.gohugo.io/hugo-theme-techdoc/">TechDoc</a>. Designed by <a href="https://github.com/thingsym/hugo-theme-techdoc">Thingsym</a>.</p>
</footer>
</main>
<div class="sidebar">

<nav class="open-menu">
<ul>
<li class=""><a href="https://probabilistic-effects.github.io/">Home</a></li>

<li class=""><a href="https://probabilistic-effects.github.io/activity/">Activity</a>
  
<ul class="sub-menu">
<li class=""><a href="https://probabilistic-effects.github.io/activity/inlining-monad-bayes/">Inlining Monad Bayes</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/activity/cps/"></a></li>
</ul>
  
</li>

<li class="parent"><a href="https://probabilistic-effects.github.io/papers/">Papers</a>
  
<ul class="sub-menu">
<li class=""><a href="https://probabilistic-effects.github.io/papers/asymptotic-improvement/">Asymptotic Improvement of Computations over Free Monads</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/papers/freer-monads/">Freer Monads, More Extensible Effects</a></li>
<li class="active"><a href="https://probabilistic-effects.github.io/papers/fusion-for-free/">Fusion for Free</a></li>
</ul>
  
</li>

<li class=""><a href="https://probabilistic-effects.github.io/research/">Research</a>
  
<ul class="sub-menu">
<li class=""><a href="https://probabilistic-effects.github.io/research/research-journal/">Research Journal</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/research/approaches-for-monad-bayes/">Potential Approaches to Improving Monad Bayes</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/research/effects-for-less/">Effects for Less</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/research/literature-review/">Literature Review</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/research/parsley-case-study/">Case Study: Optimising Parsley</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/research/optimising-core/">Optimising Core</a></li>
</ul>
  
</li>

<li class=""><a href="https://probabilistic-effects.github.io/monad-bayes/">Monad Bayes</a>
  
<ul class="sub-menu">
<li class=""><a href="https://probabilistic-effects.github.io/monad-bayes/inference-transformers/">Inference Transformers</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/monad-bayes/pmmh-hmm/">Implementing HMM Simulation and Inference (using PMMH)</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/monad-bayes/conditioning-scoring/">How Conditioning and Scoring Works</a></li>
</ul>
  
</li>

<li class=""><a href="https://probabilistic-effects.github.io/tooling/">Tooling</a>
  
<ul class="sub-menu">
<li class=""><a href="https://probabilistic-effects.github.io/tooling/cabal/">Cabal Projects</a></li>
</ul>
  
</li>

<li class=""><a href="https://probabilistic-effects.github.io/benchmarking/">Benchmarking</a>
  
<ul class="sub-menu">
<li class=""><a href="https://probabilistic-effects.github.io/benchmarking/benchmark-log/">Benchmark Log</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/benchmarking/benchmarking-profiling/">How to Benchmark and Profile</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/benchmarking/monad-bayes-components/">Relevant Components of Monad Bayes for Profiling</a></li>
</ul>
  
</li>

<li class=""><a href="https://probabilistic-effects.github.io/background/">Background</a>
  
<ul class="sub-menu">
<li class=""><a href="https://probabilistic-effects.github.io/background/staging/">Staging</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/background/smc-pmmh/">SMC and PMMH</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/background/handrolling/">Handrolling Monad Transformer Stacks</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/background/mtl/">MTL</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/background/mcmc-mh/">MCMC and MH</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/background/markov-chain/">Markov Chains</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/background/hidden-markov-model/">Hidden Markov Model</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/background/delimited-continuations/">Delimited Continuations</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/background/haskell-core/">Haskell Core</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/background/inlining/">Inlining</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/background/specialisation/">Specialisation</a></li>
<li class=""><a href="https://probabilistic-effects.github.io/background/continuations/">Continuations</a></li>
</ul>
  
</li>
</ul>
</nav>



<div class="sidebar-footer"></div>
</div>

</div><a href="#" id="backtothetop-fixed" class="backtothetop"
 data-backtothetop-duration="600"
 data-backtothetop-easing="easeOutQuart"
 data-backtothetop-fixed-fadeIn="1000"
 data-backtothetop-fixed-fadeOut="1000"
 data-backtothetop-fixed-bottom="10"
 data-backtothetop-fixed-right="20">
<span class="fa-layers fa-fw">
<i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i>
</span></a>
</div>
</body>
</html>

<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Papers on Probabilistic Effects.  λθ</title>
    <link>https://probabilistic-effects.github.io/papers/</link>
    <description>Recent content in Papers on Probabilistic Effects.  λθ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 13 Nov 2020 13:52:51 +0000</lastBuildDate><atom:link href="https://probabilistic-effects.github.io/papers/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Asymptotic Improvement of Computations over Free Monads</title>
      <link>https://probabilistic-effects.github.io/papers/asymptotic-improvement/</link>
      <pubDate>Fri, 13 Nov 2020 14:05:41 +0000</pubDate>
      
      <guid>https://probabilistic-effects.github.io/papers/asymptotic-improvement/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Design and Implementation of Probabilistic Programming Language Anglican</title>
      <link>https://probabilistic-effects.github.io/papers/anglican/</link>
      <pubDate>Fri, 13 Nov 2020 14:05:41 +0000</pubDate>
      
      <guid>https://probabilistic-effects.github.io/papers/anglican/</guid>
      <description>1. Introduction Probabilitic programming systems represent generative models as programs (given an observable variable X and a target variable Y, a generative model is a statistical model of the joint probability distribution on X × Y) written in a language that provides syntax for the definition and conditioning of random variables. Typically, inference can be performed for any probabilistic program using inference techniques provided by the system back-end, such as Metropolis-Hastings, Hamiltonian Monte Carlo, Sequential Monte Carlo, and expectation progation.</description>
    </item>
    
    <item>
      <title>Faster Coroutine Pipelines</title>
      <link>https://probabilistic-effects.github.io/papers/faster-coroutine-pipelines/</link>
      <pubDate>Fri, 13 Nov 2020 14:05:41 +0000</pubDate>
      
      <guid>https://probabilistic-effects.github.io/papers/faster-coroutine-pipelines/</guid>
      <description>2. Motivation 2.1 Pipes A unidirectional pipe can receive i</description>
    </item>
    
    <item>
      <title>Freer Monads, More Extensible Effects</title>
      <link>https://probabilistic-effects.github.io/papers/freer-monads/</link>
      <pubDate>Fri, 13 Nov 2020 14:05:41 +0000</pubDate>
      
      <guid>https://probabilistic-effects.github.io/papers/freer-monads/</guid>
      <description>1. Derivation of Free-er Monad 1.1 Reader Effect Reader computations depend on a value supplied by the environment/context. A side-effect can be understood as an interaction of an expression with its context. The possible requests of a Reader can be specified as a data type.
data It i a = Pure a | Get (i -&amp;gt; It i a) The expression Pure e marks the computation e that makes no requests, silently working towards a value of the type a.</description>
    </item>
    
    <item>
      <title>Fusion for Free</title>
      <link>https://probabilistic-effects.github.io/papers/fusion-for-free/</link>
      <pubDate>Fri, 13 Nov 2020 14:05:41 +0000</pubDate>
      
      <guid>https://probabilistic-effects.github.io/papers/fusion-for-free/</guid>
      <description>Free monads are at the heart of algebraic effect handlers, a functional approach for modelling side effects which allows the separation of the syntax and semantics of effectful operations, whilst enabling us to provide multiple different semantics for the same syntax.
The syntax of primitive side-effect operations is captured in a signature functor. The free monad over this functor assembles the syntax for the individual operations into an abstract syntax tree for an effectful program.</description>
    </item>
    
    <item>
      <title>Introduction To Probabilistic Programming</title>
      <link>https://probabilistic-effects.github.io/papers/probabilistic-programming/</link>
      <pubDate>Fri, 13 Nov 2020 14:05:41 +0000</pubDate>
      
      <guid>https://probabilistic-effects.github.io/papers/probabilistic-programming/</guid>
      <description>1.1 Model-based Reasoning A model is an artifical construct designed to respond in the same way as the system we would like to understand. As computers have evolved, numerical models have come to the forefront and computer simulations have replaced physical models. Numerical models emulate stochasticity, i.e. they use pseudorandom number generators to simulate actually random phenomena and other uncertainties. Running a simulator with stochastic value generation leads to an explosion of possible simulation outcomes.</description>
    </item>
    
    <item>
      <title>Lightweight Implementations of Probabilistic Programming Languages</title>
      <link>https://probabilistic-effects.github.io/papers/lightweight-implementations-prob-languages/</link>
      <pubDate>Fri, 13 Nov 2020 14:05:41 +0000</pubDate>
      
      <guid>https://probabilistic-effects.github.io/papers/lightweight-implementations-prob-languages/</guid>
      <description>This describes a general method of transforming arbitrary programming languages into probabilistic programming languages with straight-forward MCMC inference engines. Random choices in the program are “named” with information about their position in an execution trace; these names are used in conjunction with a database holding values of random variables to implement MCMC inference in the space of execution traces.
Probabilistic programming languages simplify the development of probabilistic models by allowing programmers to specify a stochastic (random) process using syntax resembling modern programming languages.</description>
    </item>
    
  </channel>
</rss>
